{"meta":{"title":"ONEAL.TECH","subtitle":"居安思危","description":"生活不止眼前的苟且,还有诗和远方的田野.","author":"oneal","url":"https://oneal.tech"},"pages":[{"title":"归档","date":"2018-07-21T16:23:07.000Z","updated":"2021-02-28T06:17:39.812Z","comments":false,"path":"archives/index.html","permalink":"https://oneal.tech/archives/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-02-28T06:17:39.812Z","updated":"2021-02-28T06:17:39.812Z","comments":true,"path":"tags/index.html","permalink":"https://oneal.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"服务器推送","slug":"server-push","date":"2019-03-19T15:19:38.000Z","updated":"2021-02-28T06:17:39.812Z","comments":true,"path":"back-end/2019-03-19-server-push.html","link":"","permalink":"https://oneal.tech/back-end/2019-03-19-server-push.html","excerpt":"","text":"http协议介绍 http协议是请求/响应范式的，每个http 响应都对应一个 http 请求，http协议是无状态的，多个http请求之间是没有关系的； http协议的被动性，在标准的HTTP请求响应语义中，浏览器发起请求，服务器发送一个响应，这意味着在浏览器发起新请求前，服务器不能发送新信息给客户端浏览器； Ajax短轮询Ajax长论询SSE","categories":[{"name":"后端","slug":"back-end","permalink":"https://oneal.tech/categories/back-end/"}],"tags":[{"name":"Java服务器推送","slug":"Java服务器推送","permalink":"https://oneal.tech/tags/Java服务器推送/"}]},{"title":"Java 设计模式","slug":"java设计模式","date":"2018-07-30T17:29:16.000Z","updated":"2021-02-28T06:17:39.812Z","comments":true,"path":"back-end/2018-07-30-java-design-pattern.html","link":"","permalink":"https://oneal.tech/back-end/2018-07-30-java-design-pattern.html","excerpt":"","text":"作者：CyC2018原文链接: 设计模式 一、概述设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。 拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。 源码以及 UML 图 二、创建型1. 单例（Singleton）意图确保一个类只有一个实例，并提供该实例的全局访问点。 类图使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。 私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。 实现（一）懒汉式-线程不安全 以下实现中，私有静态变量 uniqueInstance 被延迟化实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。 这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 if (uniqueInstance == null) ，并且此时 uniqueInstance 为 null，那么多个线程会执行 uniqueInstance = new Singleton(); 语句，这将导致多次实例化 uniqueInstance。 public class Singleton &#123; private static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125; （二）懒汉式-线程安全 只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了对 uniqueInstance 进行多次实例化的问题。 但是这样有一个问题，就是当一个线程进入该方法之后，其它线程试图进入该方法都必须等待，因此性能上有一定的损耗。 public static synchronized Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance;&#125; （三）饿汉式-线程安全 线程不安全问题主要是由于 uniqueInstance 被实例化了多次，如果 uniqueInstance 采用直接实例化的话，就不会被实例化多次，也就不会产生线程不安全问题。但是直接实例化的方式也丢失了延迟实例化带来的节约资源的优势。 private static Singleton uniqueInstance = new Singleton(); （四）双重校验锁-线程安全 uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行。也就是说，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。 双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。 public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程同时执行 if 语句，那么两个线程就会同时进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 uniqueInstance = new Singleton(); 这条语句，只是先后的问题，也就是说会进行两次实例化，从而产生了两个实例。因此必须使用双重校验锁，也就是需要使用两个 if 语句。 if (uniqueInstance == null) &#123; synchronized (Singleton.class) &#123; uniqueInstance = new Singleton(); &#125;&#125; uniqueInstance 采用 volatile 关键字修饰也是很有必要的。uniqueInstance = new Singleton(); 这段代码其实是分为三步执行。 分配内存空间 初始化对象 将 uniqueInstance 指向分配的内存地址 但是由于 JVM 具有指令重排的特性，有可能执行顺序变为了 1&gt;3&gt;2，这在单线程情况下自然是没有问题。但如果是多线程下，有可能获得是一个还没有被初始化的实例，以致于程序出错。 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。 （五）静态内部类实现 当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例。 这种方式不仅具有延迟初始化的好处，而且由虚拟机提供了对线程安全的支持。 public class Singleton &#123; private Singleton() &#123; &#125; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getUniqueInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; （五）枚举实现 这是单例模式的最佳实践，它实现简单，并且在面对复杂的序列化或者反射攻击的时候，能够防止实例化多次。 public enum Singleton &#123; uniqueInstance;&#125; 考虑以下单例模式的实现，该 Singleton 在每次序列化的时候都会创建一个新的实例，为了保证只创建一个实例，必须声明所有字段都是 transient，并且提供一个 readResolve() 方法。 public class Singleton implements Serializable &#123; private static Singleton uniqueInstance; private Singleton() &#123; &#125; public static synchronized Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125; 如果不使用枚举来实现单例模式，会出现反射攻击，因为通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象。如果要防止这种攻击，需要在构造函数中添加防止实例化第二个对象的代码。 从上面的讨论可以看出，解决序列化和反射攻击很麻烦，而枚举实现不会出现这两种问题，所以说枚举实现单例模式是最佳实践。 使用场景 Logger Classes Configuration Classes Accesing resources in shared mode Factories implemented as Singletons JDK java.lang.Runtime#getRuntime() java.awt.Desktop#getDesktop() java.lang.System#getSecurityManager() 2. 简单工厂（Simple Factory）意图在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。 类图简单工厂不是设计模式，更像是一种编程习惯。它把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。 这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。因为客户类往往有多个，如果不使用简单工厂，所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。 如果存在下面这种代码，就需要使用简单工厂将对象实例化的部分放到简单工厂中。 public class Client &#123; public static void main(String[] args) &#123; int type = 1; Product product; if (type == 1) &#123; product = new ConcreteProduct1(); &#125; else if (type == 2) &#123; product = new ConcreteProduct2(); &#125; else &#123; product = new ConcreteProduct(); &#125; &#125;&#125; 实现public interface Product &#123;&#125; public class ConcreteProduct implements Product &#123;&#125; public class ConcreteProduct1 implements Product &#123;&#125; public class ConcreteProduct2 implements Product &#123;&#125; public class SimpleFactory &#123; public Product createProduct(int type) &#123; if (type == 1) &#123; return new ConcreteProduct1(); &#125; else if (type == 2) &#123; return new ConcreteProduct2(); &#125; return new ConcreteProduct(); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; SimpleFactory simpleFactory = new SimpleFactory(); Product product = simpleFactory.createProduct(1); &#125;&#125; 3. 工厂方法（Factory Method）意图定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化推迟到子类。 类图在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。 下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。 实现public abstract class Factory &#123; abstract public Product factoryMethod(); public void doSomething() &#123; Product product = factoryMethod(); // do something with the product &#125;&#125; public class ConcreteFactory extends Factory &#123; public Product factoryMethod() &#123; return new ConcreteProduct(); &#125;&#125; public class ConcreteFactory1 extends Factory &#123; public Product factoryMethod() &#123; return new ConcreteProduct1(); &#125;&#125; public class ConcreteFactory2 extends Factory &#123; public Product factoryMethod() &#123; return new ConcreteProduct2(); &#125;&#125; JDK java.util.Calendar java.util.ResourceBundle java.text.NumberFormat java.nio.charset.Charset java.net.URLStreamHandlerFactory java.util.EnumSet javax.xml.bind.JAXBContext 4. 抽象工厂（Abstract Factory）意图提供一个接口，用于创建 相关的对象家族 。 类图抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。 抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。 至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。 从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。 代码实现public class AbstractProductA &#123;&#125; public class AbstractProductB &#123;&#125; public class ProductA1 extends AbstractProductA &#123;&#125; public class ProductA2 extends AbstractProductA &#123;&#125; public class ProductB1 extends AbstractProductB &#123;&#125; public class ProductB2 extends AbstractProductB &#123;&#125; public abstract class AbstractFactory &#123; abstract AbstractProductA createProductA(); abstract AbstractProductB createProductB();&#125; public class ConcreteFactory1 extends AbstractFactory &#123; AbstractProductA createProductA() &#123; return new ProductA1(); &#125; AbstractProductB createProductB() &#123; return new ProductB1(); &#125;&#125; public class ConcreteFactory2 extends AbstractFactory &#123; AbstractProductA createProductA() &#123; return new ProductA2(); &#125; AbstractProductB createProductB() &#123; return new ProductB2(); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; AbstractFactory abstractFactory = new ConcreteFactory1(); AbstractProductA productA = abstractFactory.createProductA(); AbstractProductB productB = abstractFactory.createProductB(); // do something with productA and productB &#125;&#125; JDK javax.xml.parsers.DocumentBuilderFactory javax.xml.transform.TransformerFactory javax.xml.xpath.XPathFactory 5. 生成器（Builder）意图封装一个对象的构造过程，并允许按步骤构造。 类图 实现以下是一个简易的 StringBuilder 实现，参考了 JDK 1.8 源码。 public class AbstractStringBuilder &#123; protected char[] value; protected int count; public AbstractStringBuilder(int capacity) &#123; count = 0; value = new char[capacity]; &#125; public AbstractStringBuilder append(char c) &#123; ensureCapacityInternal(count + 1); value[count++] = c; return this; &#125; private void ensureCapacityInternal(int minimumCapacity) &#123; // overflow-conscious code if (minimumCapacity - value.length &gt; 0) expandCapacity(minimumCapacity); &#125; void expandCapacity(int minimumCapacity) &#123; int newCapacity = value.length * 2 + 2; if (newCapacity - minimumCapacity &lt; 0) newCapacity = minimumCapacity; if (newCapacity &lt; 0) &#123; if (minimumCapacity &lt; 0) // overflow throw new OutOfMemoryError(); newCapacity = Integer.MAX_VALUE; &#125; value = Arrays.copyOf(value, newCapacity); &#125;&#125; public class StringBuilder extends AbstractStringBuilder &#123; public StringBuilder() &#123; super(16); &#125; @Override public String toString() &#123; // Create a copy, don't share the array return new String(value, 0, count); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; StringBuilder sb = new StringBuilder(); final int count = 26; for (int i = 0; i &lt; count; i++) &#123; sb.append((char) ('a' + i)); &#125; System.out.println(sb.toString()); &#125;&#125; abcdefghijklmnopqrstuvwxyz JDK java.lang.StringBuilder java.nio.ByteBuffer java.lang.StringBuffer java.lang.Appendable Apache Camel builders 6. 原型模式（Prototype）意图使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。 类图 实现public abstract class Prototype &#123; abstract Prototype myClone();&#125; public class ConcretePrototype extends Prototype &#123; private String filed; public ConcretePrototype(String filed) &#123; this.filed = filed; &#125; @Override Prototype myClone() &#123; return new ConcretePrototype(filed); &#125; @Override public String toString() &#123; return filed; &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Prototype prototype = new ConcretePrototype(\"abc\"); Prototype clone = prototype.myClone(); System.out.println(clone.toString()); &#125;&#125; abc JDK java.lang.Object#clone() 三、行为型1. 责任链（Chain Of Responsibility）意图使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。 类图 Handler：定义处理请求的接口，并且实现后继链（successor） 实现public abstract class Handler &#123; protected Handler successor; public Handler(Handler successor) &#123; this.successor = successor; &#125; protected abstract void handleRequest(Request request);&#125; public class ConcreteHandler1 extends Handler &#123; public ConcreteHandler1(Handler successor) &#123; super(successor); &#125; @Override protected void handleRequest(Request request) &#123; if (request.getType() == RequestType.type1) &#123; System.out.println(request.getName() + \" is handle by ConcreteHandler1\"); return; &#125; if (successor != null) &#123; successor.handleRequest(request); &#125; &#125;&#125; public class ConcreteHandler2 extends Handler&#123; public ConcreteHandler2(Handler successor) &#123; super(successor); &#125; @Override protected void handleRequest(Request request) &#123; if (request.getType() == RequestType.type2) &#123; System.out.println(request.getName() + \" is handle by ConcreteHandler2\"); return; &#125; if (successor != null) &#123; successor.handleRequest(request); &#125; &#125;&#125; public class Request &#123; private RequestType type; private String name; public Request(RequestType type, String name) &#123; this.type = type; this.name = name; &#125; public RequestType getType() &#123; return type; &#125; public String getName() &#123; return name; &#125;&#125; public enum RequestType &#123; type1, type2&#125; public class Client &#123; public static void main(String[] args) &#123; Handler handler1 = new ConcreteHandler1(null); Handler handler2 = new ConcreteHandler2(handler1); Request request1 = new Request(RequestType.type1, \"request1\"); handler2.handleRequest(request1); Request request2 = new Request(RequestType.type2, \"request2\"); handler2.handleRequest(request2); &#125;&#125; request1 is handle by ConcreteHandler1request2 is handle by ConcreteHandler2 JDK java.util.logging.Logger#log() Apache Commons Chain javax.servlet.Filter#doFilter() 2. 命令（Command）意图将命令封装成对象中，以便使用命令来参数化其它对象，或者将命令对象放入队列中进行排队，或者将命令对象的操作记录到日志中，以及支持可撤销的操作。 类图 Command：命令 Receiver：命令接收者，也就是命令真正的执行者 Invoker：通过它来调用命令 Client：可以设置命令与命令的接收者 实现设计一个遥控器，可以控制电灯开关。 public interface Command &#123; void execute();&#125; public class LightOnCommand implements Command &#123; Light light; public LightOnCommand(Light light) &#123; this.light = light; &#125; @Override public void execute() &#123; light.on(); &#125;&#125; public class LightOffCommand implements Command &#123; Light light; public LightOffCommand(Light light) &#123; this.light = light; &#125; @Override public void execute() &#123; light.off(); &#125;&#125; public class Light &#123; public void on() &#123; System.out.println(\"Light is on!\"); &#125; public void off() &#123; System.out.println(\"Light is off!\"); &#125;&#125; /** * 遥控器 */public class Invoker &#123; private Command[] onCommands; private Command[] offCommands; private final int slotNum = 7; public Invoker() &#123; this.onCommands = new Command[slotNum]; this.offCommands = new Command[slotNum]; &#125; public void setOnCommand(Command command, int slot) &#123; onCommands[slot] = command; &#125; public void setOffCommand(Command command, int slot) &#123; offCommands[slot] = command; &#125; public void onButtonWasPushed(int slot) &#123; onCommands[slot].execute(); &#125; public void offButtonWasPushed(int slot) &#123; offCommands[slot].execute(); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Invoker invoker = new Invoker(); Light light = new Light(); Command lightOnCommand = new LightOnCommand(light); Command lightOffCommand = new LightOffCommand(light); invoker.setOnCommand(lightOnCommand, 0); invoker.setOffCommand(lightOffCommand, 0); invoker.onButtonWasPushed(0); invoker.offButtonWasPushed(0); &#125;&#125; JDK java.lang.Runnable Netflix Hystrix javax.swing.Action 3. 解释器（Interpreter）意图为语言创建解释器，通常由语言的语法和语法分析来定义。 类图 TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression Context：上下文，包含解释器之外的一些全局信息 实现以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。 例如一颗解析树为 D And (A Or (B C))，文本 “D A” 满足该解析树定义的规则。 这里的 Context 指的是 String。 public abstract class Expression &#123; public abstract boolean interpret(String str);&#125; public class TerminalExpression extends Expression &#123; private String literal = null; public TerminalExpression(String str) &#123; literal = str; &#125; public boolean interpret(String str) &#123; StringTokenizer st = new StringTokenizer(str); while (st.hasMoreTokens()) &#123; String test = st.nextToken(); if (test.equals(literal)) &#123; return true; &#125; &#125; return false; &#125;&#125; public class AndExpression extends Expression &#123; private Expression expression1 = null; private Expression expression2 = null; public AndExpression(Expression expression1, Expression expression2) &#123; this.expression1 = expression1; this.expression2 = expression2; &#125; public boolean interpret(String str) &#123; return expression1.interpret(str) &amp;&amp; expression2.interpret(str); &#125;&#125; public class OrExpression extends Expression &#123; private Expression expression1 = null; private Expression expression2 = null; public OrExpression(Expression expression1, Expression expression2) &#123; this.expression1 = expression1; this.expression2 = expression2; &#125; public boolean interpret(String str) &#123; return expression1.interpret(str) || expression2.interpret(str); &#125;&#125; public class Client &#123; /** * 构建解析树 */ public static Expression buildInterpreterTree() &#123; // Literal Expression terminal1 = new TerminalExpression(\"A\"); Expression terminal2 = new TerminalExpression(\"B\"); Expression terminal3 = new TerminalExpression(\"C\"); Expression terminal4 = new TerminalExpression(\"D\"); // B C Expression alternation1 = new OrExpression(terminal2, terminal3); // A Or (B C) Expression alternation2 = new OrExpression(terminal1, alternation1); // D And (A Or (B C)) return new AndExpression(terminal4, alternation2); &#125; public static void main(String[] args) &#123; Expression define = buildInterpreterTree(); String context1 = \"D A\"; String context2 = \"A B\"; System.out.println(define.interpret(context1)); System.out.println(define.interpret(context2)); &#125;&#125; truefalse JDK java.util.Pattern java.text.Normalizer All subclasses of java.text.Format javax.el.ELResolver 4. 迭代器（Iterator）意图提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。 类图 Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator； Iterator 主要定义了 hasNext() 和 next() 方法。 Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。 实现public interface Aggregate &#123; Iterator createIterator();&#125; public class ConcreteAggregate implements Aggregate &#123; private Integer[] items; public ConcreteAggregate() &#123; items = new Integer[10]; for (int i = 0; i &lt; items.length; i++) &#123; items[i] = i; &#125; &#125; @Override public Iterator createIterator() &#123; return new ConcreteIterator&lt;Integer&gt;(items); &#125;&#125; public interface Iterator&lt;Item&gt; &#123; Item next(); boolean hasNext();&#125; public class ConcreteIterator&lt;Item&gt; implements Iterator &#123; private Item[] items; private int position = 0; public ConcreteIterator(Item[] items) &#123; this.items = items; &#125; @Override public Object next() &#123; return items[position++]; &#125; @Override public boolean hasNext() &#123; return position &lt; items.length; &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Aggregate aggregate = new ConcreteAggregate(); Iterator&lt;Integer&gt; iterator = aggregate.createIterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;&#125; JDK java.util.Iterator java.util.Enumeration 5. 中介者（Mediator）意图集中相关对象之间复杂的沟通和控制方式。 类图 Mediator：中介者，定义一个接口用于与各同事（Colleague）对象通信。 Colleague：同事，相关对象 实现Alarm（闹钟）、CoffeePot（咖啡壶）、Calendar（日历）、Sprinkler（喷头）是一组相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构： 使用中介者模式可以将复杂的依赖结构变成星形结构： public abstract class Colleague &#123; public abstract void onEvent(Mediator mediator);&#125; public class Alarm extends Colleague &#123; @Override public void onEvent(Mediator mediator) &#123; mediator.doEvent(\"alarm\"); &#125; public void doAlarm() &#123; System.out.println(\"doAlarm()\"); &#125;&#125; public class CoffeePot extends Colleague &#123; @Override public void onEvent(Mediator mediator) &#123; mediator.doEvent(\"coffeePot\"); &#125; public void doCoffeePot() &#123; System.out.println(\"doCoffeePot()\"); &#125;&#125; public class Calender extends Colleague &#123; @Override public void onEvent(Mediator mediator) &#123; mediator.doEvent(\"calender\"); &#125; public void doCalender() &#123; System.out.println(\"doCalender()\"); &#125;&#125; public class Sprinkler extends Colleague &#123; @Override public void onEvent(Mediator mediator) &#123; mediator.doEvent(\"sprinkler\"); &#125; public void doSprinkler() &#123; System.out.println(\"doSprinkler()\"); &#125;&#125; public abstract class Mediator &#123; public abstract void doEvent(String eventType);&#125; public class ConcreteMediator extends Mediator &#123; private Alarm alarm; private CoffeePot coffeePot; private Calender calender; private Sprinkler sprinkler; public ConcreteMediator(Alarm alarm, CoffeePot coffeePot, Calender calender, Sprinkler sprinkler) &#123; this.alarm = alarm; this.coffeePot = coffeePot; this.calender = calender; this.sprinkler = sprinkler; &#125; @Override public void doEvent(String eventType) &#123; switch (eventType) &#123; case \"alarm\": doAlarmEvent(); break; case \"coffeePot\": doCoffeePotEvent(); break; case \"calender\": doCalenderEvent(); break; default: doSprinklerEvent(); &#125; &#125; public void doAlarmEvent() &#123; alarm.doAlarm(); coffeePot.doCoffeePot(); calender.doCalender(); sprinkler.doSprinkler(); &#125; public void doCoffeePotEvent() &#123; // ... &#125; public void doCalenderEvent() &#123; // ... &#125; public void doSprinklerEvent() &#123; // ... &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Alarm alarm = new Alarm(); CoffeePot coffeePot = new CoffeePot(); Calender calender = new Calender(); Sprinkler sprinkler = new Sprinkler(); Mediator mediator = new ConcreteMediator(alarm, coffeePot, calender, sprinkler); // 闹钟事件到达，调用中介者就可以操作相关对象 alarm.onEvent(mediator); &#125;&#125; doAlarm()doCoffeePot()doCalender()doSprinkler() JDK All scheduleXXX() methods of java.util.Timer java.util.concurrent.Executor#execute() submit() and invokeXXX() methods of java.util.concurrent.ExecutorService scheduleXXX() methods of java.util.concurrent.ScheduledExecutorService java.lang.reflect.Method#invoke() 6. 备忘录（Memento）意图在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。 类图 Originator：原始对象 Caretaker：负责保存好备忘录 Menento：备忘录，存储原始对象的的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。 实现以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。 实现参考：Memento Pattern - Calculator Example - Java Sourcecode /** * Originator Interface */public interface Calculator &#123; // Create Memento PreviousCalculationToCareTaker backupLastCalculation(); // setMemento void restorePreviousCalculation(PreviousCalculationToCareTaker memento); int getCalculationResult(); void setFirstNumber(int firstNumber); void setSecondNumber(int secondNumber);&#125; /** * Originator Implementation */public class CalculatorImp implements Calculator &#123; private int firstNumber; private int secondNumber; @Override public PreviousCalculationToCareTaker backupLastCalculation() &#123; // create a memento object used for restoring two numbers return new PreviousCalculationImp(firstNumber, secondNumber); &#125; @Override public void restorePreviousCalculation(PreviousCalculationToCareTaker memento) &#123; this.firstNumber = ((PreviousCalculationToOriginator) memento).getFirstNumber(); this.secondNumber = ((PreviousCalculationToOriginator) memento).getSecondNumber(); &#125; @Override public int getCalculationResult() &#123; // result is adding two numbers return firstNumber + secondNumber; &#125; @Override public void setFirstNumber(int firstNumber) &#123; this.firstNumber = firstNumber; &#125; @Override public void setSecondNumber(int secondNumber) &#123; this.secondNumber = secondNumber; &#125;&#125; /** * Memento Interface to Originator * * This interface allows the originator to restore its state */public interface PreviousCalculationToOriginator &#123; int getFirstNumber(); int getSecondNumber();&#125; /** * Memento interface to CalculatorOperator (Caretaker) */public interface PreviousCalculationToCareTaker &#123; // no operations permitted for the caretaker&#125; /** * Memento Object Implementation * &lt;p&gt; * Note that this object implements both interfaces to Originator and CareTaker */public class PreviousCalculationImp implements PreviousCalculationToCareTaker, PreviousCalculationToOriginator &#123; private int firstNumber; private int secondNumber; public PreviousCalculationImp(int firstNumber, int secondNumber) &#123; this.firstNumber = firstNumber; this.secondNumber = secondNumber; &#125; @Override public int getFirstNumber() &#123; return firstNumber; &#125; @Override public int getSecondNumber() &#123; return secondNumber; &#125;&#125; /** * CareTaker object */public class Client &#123; public static void main(String[] args) &#123; // program starts Calculator calculator = new CalculatorImp(); // assume user enters two numbers calculator.setFirstNumber(10); calculator.setSecondNumber(100); // find result System.out.println(calculator.getCalculationResult()); // Store result of this calculation in case of error PreviousCalculationToCareTaker memento = calculator.backupLastCalculation(); // user enters a number calculator.setFirstNumber(17); // user enters a wrong second number and calculates result calculator.setSecondNumber(-290); // calculate result System.out.println(calculator.getCalculationResult()); // user hits CTRL + Z to undo last operation and see last result calculator.restorePreviousCalculation(memento); // result restored System.out.println(calculator.getCalculationResult()); &#125;&#125; 110-273110 JDK java.io.Serializable 7. 观察者（Observer）意图定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。 主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。 类图主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。 观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。 实现天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。 public interface Subject &#123; void resisterObserver(Observer o); void removeObserver(Observer o); void notifyObserver();&#125; public class WeatherData implements Subject &#123; private List&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; observers = new ArrayList&lt;&gt;(); &#125; public void setMeasurements(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; notifyObserver(); &#125; @Override public void resisterObserver(Observer o) &#123; observers.add(o); &#125; @Override public void removeObserver(Observer o) &#123; int i = observers.indexOf(o); if (i &gt;= 0) &#123; observers.remove(i); &#125; &#125; @Override public void notifyObserver() &#123; for (Observer o : observers) &#123; o.update(temperature, humidity, pressure); &#125; &#125;&#125; public interface Observer &#123; void update(float temp, float humidity, float pressure);&#125; public class StatisticsDisplay implements Observer &#123; public StatisticsDisplay(Subject weatherData) &#123; weatherData.resisterObserver(this); &#125; @Override public void update(float temp, float humidity, float pressure) &#123; System.out.println(\"StatisticsDisplay.update: \" + temp + \" \" + humidity + \" \" + pressure); &#125;&#125; public class CurrentConditionsDisplay implements Observer &#123; public CurrentConditionsDisplay(Subject weatherData) &#123; weatherData.resisterObserver(this); &#125; @Override public void update(float temp, float humidity, float pressure) &#123; System.out.println(\"CurrentConditionsDisplay.update: \" + temp + \" \" + humidity + \" \" + pressure); &#125;&#125; public class WeatherStation &#123; public static void main(String[] args) &#123; WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData); StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData); weatherData.setMeasurements(0, 0, 0); weatherData.setMeasurements(1, 1, 1); &#125;&#125; CurrentConditionsDisplay.update: 0.0 0.0 0.0StatisticsDisplay.update: 0.0 0.0 0.0CurrentConditionsDisplay.update: 1.0 1.0 1.0StatisticsDisplay.update: 1.0 1.0 1.0 JDK java.util.Observer java.util.EventListener javax.servlet.http.HttpSessionBindingListener RxJava 8. 状态（State）意图允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。 类图 实现糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。 public interface State &#123; /** * 投入 25 分钱 */ void insertQuarter(); /** * 退回 25 分钱 */ void ejectQuarter(); /** * 转动曲柄 */ void turnCrank(); /** * 发放糖果 */ void dispense();&#125; public class HasQuarterState implements State &#123; private GumballMachine gumballMachine; public HasQuarterState(GumballMachine gumballMachine) &#123; this.gumballMachine = gumballMachine; &#125; @Override public void insertQuarter() &#123; System.out.println(\"You can't insert another quarter\"); &#125; @Override public void ejectQuarter() &#123; System.out.println(\"Quarter returned\"); gumballMachine.setState(gumballMachine.getNoQuarterState()); &#125; @Override public void turnCrank() &#123; System.out.println(\"You turned...\"); gumballMachine.setState(gumballMachine.getSoldState()); &#125; @Override public void dispense() &#123; System.out.println(\"No gumball dispensed\"); &#125;&#125; public class NoQuarterState implements State &#123; GumballMachine gumballMachine; public NoQuarterState(GumballMachine gumballMachine) &#123; this.gumballMachine = gumballMachine; &#125; @Override public void insertQuarter() &#123; System.out.println(\"You insert a quarter\"); gumballMachine.setState(gumballMachine.getHasQuarterState()); &#125; @Override public void ejectQuarter() &#123; System.out.println(\"You haven't insert a quarter\"); &#125; @Override public void turnCrank() &#123; System.out.println(\"You turned, but there's no quarter\"); &#125; @Override public void dispense() &#123; System.out.println(\"You need to pay first\"); &#125;&#125; public class SoldOutState implements State &#123; GumballMachine gumballMachine; public SoldOutState(GumballMachine gumballMachine) &#123; this.gumballMachine = gumballMachine; &#125; @Override public void insertQuarter() &#123; System.out.println(\"You can't insert a quarter, the machine is sold out\"); &#125; @Override public void ejectQuarter() &#123; System.out.println(\"You can't eject, you haven't inserted a quarter yet\"); &#125; @Override public void turnCrank() &#123; System.out.println(\"You turned, but there are no gumballs\"); &#125; @Override public void dispense() &#123; System.out.println(\"No gumball dispensed\"); &#125;&#125; public class SoldState implements State &#123; GumballMachine gumballMachine; public SoldState(GumballMachine gumballMachine) &#123; this.gumballMachine = gumballMachine; &#125; @Override public void insertQuarter() &#123; System.out.println(\"Please wait, we're already giving you a gumball\"); &#125; @Override public void ejectQuarter() &#123; System.out.println(\"Sorry, you already turned the crank\"); &#125; @Override public void turnCrank() &#123; System.out.println(\"Turning twice doesn't get you another gumball!\"); &#125; @Override public void dispense() &#123; gumballMachine.releaseBall(); if (gumballMachine.getCount() &gt; 0) &#123; gumballMachine.setState(gumballMachine.getNoQuarterState()); &#125; else &#123; System.out.println(\"Oops, out of gumballs\"); gumballMachine.setState(gumballMachine.getSoldOutState()); &#125; &#125;&#125; public class GumballMachine &#123; private State soldOutState; private State noQuarterState; private State hasQuarterState; private State soldState; private State state; private int count = 0; public GumballMachine(int numberGumballs) &#123; count = numberGumballs; soldOutState = new SoldOutState(this); noQuarterState = new NoQuarterState(this); hasQuarterState = new HasQuarterState(this); soldState = new SoldState(this); if (numberGumballs &gt; 0) &#123; state = noQuarterState; &#125; else &#123; state = soldOutState; &#125; &#125; public void insertQuarter() &#123; state.insertQuarter(); &#125; public void ejectQuarter() &#123; state.ejectQuarter(); &#125; public void turnCrank() &#123; state.turnCrank(); state.dispense(); &#125; public void setState(State state) &#123; this.state = state; &#125; public void releaseBall() &#123; System.out.println(\"A gumball comes rolling out the slot...\"); if (count != 0) &#123; count -= 1; &#125; &#125; public State getSoldOutState() &#123; return soldOutState; &#125; public State getNoQuarterState() &#123; return noQuarterState; &#125; public State getHasQuarterState() &#123; return hasQuarterState; &#125; public State getSoldState() &#123; return soldState; &#125; public int getCount() &#123; return count; &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; GumballMachine gumballMachine = new GumballMachine(5); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.ejectQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.ejectQuarter(); gumballMachine.insertQuarter(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); &#125;&#125; You insert a quarterYou turned...A gumball comes rolling out the slot...You insert a quarterQuarter returnedYou turned, but there's no quarterYou need to pay firstYou insert a quarterYou turned...A gumball comes rolling out the slot...You insert a quarterYou turned...A gumball comes rolling out the slot...You haven't insert a quarterYou insert a quarterYou can't insert another quarterYou turned...A gumball comes rolling out the slot...You insert a quarterYou turned...A gumball comes rolling out the slot...Oops, out of gumballsYou can't insert a quarter, the machine is sold outYou turned, but there are no gumballsNo gumball dispensed 9. 策略（Strategy）意图定义一系列算法，封装每个算法，并使它们可以互换。 策略模式可以让算法独立于使用它的客户端。 类图 Strategy 接口定义了一个算法族，它们都具有 behavior() 方法。 Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(in Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。 与状态模式的比较状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。 但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。 所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。 状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。 实现设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。 public interface QuackBehavior &#123; void quack();&#125; public class Quack implements QuackBehavior &#123; @Override public void quack() &#123; System.out.println(\"quack!\"); &#125;&#125; public class Squeak implements QuackBehavior&#123; @Override public void quack() &#123; System.out.println(\"squeak!\"); &#125;&#125; public class Duck &#123; private QuackBehavior quackBehavior; public void performQuack() &#123; if (quackBehavior != null) &#123; quackBehavior.quack(); &#125; &#125; public void setQuackBehavior(QuackBehavior quackBehavior) &#123; this.quackBehavior = quackBehavior; &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Duck duck = new Duck(); duck.setQuackBehavior(new Squeak()); duck.performQuack(); duck.setQuackBehavior(new Quack()); duck.performQuack(); &#125;&#125; squeak!quack! JDK java.util.Comparator#compare() javax.servlet.http.HttpServlet javax.servlet.Filter#doFilter() 10. 模板方法（Template Method）意图定义算法框架，并将一些步骤的实现延迟到子类。 通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。 类图 实现冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。 public abstract class CaffeineBeverage &#123; final void prepareRecipe() &#123; boilWater(); brew(); pourInCup(); addCondiments(); &#125; abstract void brew(); abstract void addCondiments(); void boilWater() &#123; System.out.println(\"boilWater\"); &#125; void pourInCup() &#123; System.out.println(\"pourInCup\"); &#125;&#125; public class Coffee extends CaffeineBeverage&#123; @Override void brew() &#123; System.out.println(\"Coffee.brew\"); &#125; @Override void addCondiments() &#123; System.out.println(\"Coffee.addCondiments\"); &#125;&#125; public class Tea extends CaffeineBeverage&#123; @Override void brew() &#123; System.out.println(\"Tea.brew\"); &#125; @Override void addCondiments() &#123; System.out.println(\"Tea.addCondiments\"); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; CaffeineBeverage caffeineBeverage = new Coffee(); caffeineBeverage.prepareRecipe(); System.out.println(\"-----------\"); caffeineBeverage = new Tea(); caffeineBeverage.prepareRecipe(); &#125;&#125; boilWaterCoffee.brewpourInCupCoffee.addCondiments-----------boilWaterTea.brewpourInCupTea.addCondiments JDK java.util.Collections#sort() java.io.InputStream#skip() java.io.InputStream#read() java.util.AbstractList#indexOf() 11. 访问者（Visitor）意图为一个对象结构（比如组合结构）增加新能力。 类图 Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作 ConcreteVisitor：具体访问者，存储遍历过程中的累计结果 ObjectStructure：对象结构，可以是组合结构，或者是一个集合。 实现public interface Element &#123; void accept(Visitor visitor);&#125; class CustomerGroup &#123; private List&lt;Customer&gt; customers = new ArrayList&lt;&gt;(); void accept(Visitor visitor) &#123; for (Customer customer : customers) &#123; customer.accept(visitor); &#125; &#125; void addCustomer(Customer customer) &#123; customers.add(customer); &#125;&#125; public class Customer implements Element &#123; private String name; private List&lt;Order&gt; orders = new ArrayList&lt;&gt;(); Customer(String name) &#123; this.name = name; &#125; String getName() &#123; return name; &#125; void addOrder(Order order) &#123; orders.add(order); &#125; public void accept(Visitor visitor) &#123; visitor.visit(this); for (Order order : orders) &#123; order.accept(visitor); &#125; &#125;&#125; public class Order implements Element &#123; private String name; private List&lt;Item&gt; items = new ArrayList(); Order(String name) &#123; this.name = name; &#125; Order(String name, String itemName) &#123; this.name = name; this.addItem(new Item(itemName)); &#125; String getName() &#123; return name; &#125; void addItem(Item item) &#123; items.add(item); &#125; public void accept(Visitor visitor) &#123; visitor.visit(this); for (Item item : items) &#123; item.accept(visitor); &#125; &#125;&#125; public class Item implements Element &#123; private String name; Item(String name) &#123; this.name = name; &#125; String getName() &#123; return name; &#125; public void accept(Visitor visitor) &#123; visitor.visit(this); &#125;&#125; public interface Visitor &#123; void visit(Customer customer); void visit(Order order); void visit(Item item);&#125; public class GeneralReport implements Visitor &#123; private int customersNo; private int ordersNo; private int itemsNo; public void visit(Customer customer) &#123; System.out.println(customer.getName()); customersNo++; &#125; public void visit(Order order) &#123; System.out.println(order.getName()); ordersNo++; &#125; public void visit(Item item) &#123; System.out.println(item.getName()); itemsNo++; &#125; public void displayResults() &#123; System.out.println(\"Number of customers: \" + customersNo); System.out.println(\"Number of orders: \" + ordersNo); System.out.println(\"Number of items: \" + itemsNo); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Customer customer1 = new Customer(\"customer1\"); customer1.addOrder(new Order(\"order1\", \"item1\")); customer1.addOrder(new Order(\"order2\", \"item1\")); customer1.addOrder(new Order(\"order3\", \"item1\")); Order order = new Order(\"order_a\"); order.addItem(new Item(\"item_a1\")); order.addItem(new Item(\"item_a2\")); order.addItem(new Item(\"item_a3\")); Customer customer2 = new Customer(\"customer2\"); customer2.addOrder(order); CustomerGroup customers = new CustomerGroup(); customers.addCustomer(customer1); customers.addCustomer(customer2); GeneralReport visitor = new GeneralReport(); customers.accept(visitor); visitor.displayResults(); &#125;&#125; customer1order1item1order2item1order3item1customer2order_aitem_a1item_a2item_a3Number of customers: 2Number of orders: 4Number of items: 6 JDK javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor 12. 空对象（Null）意图使用什么都不做的空对象来替代 NULL。 一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。 类图 实现public abstract class AbstractOperation &#123; abstract void request();&#125; public class RealOperation extends AbstractOperation &#123; @Override void request() &#123; System.out.println(\"do something\"); &#125;&#125; public class NullOperation extends AbstractOperation&#123; @Override void request() &#123; // do nothing &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; AbstractOperation abstractOperation = func(-1); abstractOperation.request(); &#125; public static AbstractOperation func(int para) &#123; if (para &lt; 0) &#123; return new NullOperation(); &#125; return new RealOperation(); &#125;&#125; 四、结构型1. 适配器（Adapter）意图把一个类接口转换成另一个用户需要的接口。 类图 实现鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。 要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！ public interface Duck &#123; void quack();&#125; public interface Turkey &#123; void gobble();&#125; public class WildTurkey implements Turkey &#123; @Override public void gobble() &#123; System.out.println(\"gobble!\"); &#125;&#125; public class TurkeyAdapter implements Duck &#123; Turkey turkey; public TurkeyAdapter(Turkey turkey) &#123; this.turkey = turkey; &#125; @Override public void quack() &#123; turkey.gobble(); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Turkey turkey = new WildTurkey(); Duck duck = new TurkeyAdapter(turkey); duck.quack(); &#125;&#125; JDK java.util.Arrays#asList() java.util.Collections#list() java.util.Collections#enumeration() javax.xml.bind.annotation.adapters.XMLAdapter 2. 桥接（Bridge）意图将抽象与实现分离开来，使它们可以独立变化。 类图 Abstraction：定义抽象类的接口 Implementor：定义实现类接口 实现RemoteControl 表示遥控器，指代 Abstraction。 TV 表示电视，指代 Implementor。 桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。 public abstract class TV &#123; public abstract void on(); public abstract void off(); public abstract void tuneChannel();&#125; public class Sony extends TV&#123; @Override public void on() &#123; System.out.println(\"Sony.on()\"); &#125; @Override public void off() &#123; System.out.println(\"Sony.off()\"); &#125; @Override public void tuneChannel() &#123; System.out.println(\"Sony.tuneChannel()\"); &#125;&#125; public class RCA extends TV&#123; @Override public void on() &#123; System.out.println(\"RCA.on()\"); &#125; @Override public void off() &#123; System.out.println(\"RCA.off()\"); &#125; @Override public void tuneChannel() &#123; System.out.println(\"RCA.tuneChannel()\"); &#125;&#125; public abstract class RemoteControl &#123; protected TV tv; public RemoteControl(TV tv) &#123; this.tv = tv; &#125; public abstract void on(); public abstract void off(); public abstract void tuneChannel();&#125; public class ConcreteRemoteControl1 extends RemoteControl &#123; public ConcreteRemoteControl1(TV tv) &#123; super(tv); &#125; @Override public void on() &#123; System.out.println(\"ConcreteRemoteControl1.on()\"); tv.on(); &#125; @Override public void off() &#123; System.out.println(\"ConcreteRemoteControl1.off()\"); tv.off(); &#125; @Override public void tuneChannel() &#123; System.out.println(\"ConcreteRemoteControl1.tuneChannel()\"); tv.tuneChannel(); &#125;&#125; public class ConcreteRemoteControl2 extends RemoteControl &#123; public ConcreteRemoteControl2(TV tv) &#123; super(tv); &#125; @Override public void on() &#123; System.out.println(\"ConcreteRemoteControl2.on()\"); tv.on(); &#125; @Override public void off() &#123; System.out.println(\"ConcreteRemoteControl2.off()\"); tv.off(); &#125; @Override public void tuneChannel() &#123; System.out.println(\"ConcreteRemoteControl2.tuneChannel()\"); tv.tuneChannel(); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; RemoteControl remoteControl1 = new ConcreteRemoteControl1(new RCA()); remoteControl1.on(); remoteControl1.off(); remoteControl1.tuneChannel(); &#125;&#125; JDK AWT (It provides an abstraction layer which maps onto the native OS the windowing support.) JDBC 3. 组合（Composite）意图将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。 类图组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。 组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。 实现public abstract class Component &#123; protected String name; public Component(String name) &#123; this.name = name; &#125; public void print() &#123; print(0); &#125; abstract void print(int level); abstract public void add(Component component); abstract public void remove(Component component);&#125; import java.util.ArrayList;import java.util.List;public class Composite extends Component &#123; private List&lt;Component&gt; child; public Composite(String name) &#123; super(name); child = new ArrayList&lt;&gt;(); &#125; @Override void print(int level) &#123; for (int i = 0; i &lt; level; i++) &#123; System.out.print(\"--\"); &#125; System.out.println(\"Composite:\" + name); for (Component component : child) &#123; component.print(level + 1); &#125; &#125; @Override public void add(Component component) &#123; child.add(component); &#125; @Override public void remove(Component component) &#123; child.remove(component); &#125;&#125; public class Leaf extends Component &#123; public Leaf(String name) &#123; super(name); &#125; @Override void print(int level) &#123; for (int i = 0; i &lt; level; i++) &#123; System.out.print(\"--\"); &#125; System.out.println(\"left:\" + name); &#125; @Override public void add(Component component) &#123; throw new UnsupportedOperationException(); // 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点 &#125; @Override public void remove(Component component) &#123; throw new UnsupportedOperationException(); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Composite root = new Composite(\"root\"); Component node1 = new Leaf(\"1\"); Component node2 = new Composite(\"2\"); Component node3 = new Leaf(\"3\"); root.add(node1); root.add(node2); root.add(node3); Component node21 = new Leaf(\"21\"); Component node22 = new Composite(\"22\"); node2.add(node21); node2.add(node22); Component node221 = new Leaf(\"221\"); node22.add(node221); root.print(); &#125;&#125; Composite:root--left:1--Composite:2----left:21----Composite:22------left:221--left:3 JDK javax.swing.JComponent#add(Component) java.awt.Container#add(Component) java.util.Map#putAll(Map) java.util.List#addAll(Collection) java.util.Set#addAll(Collection) 4. 装饰（Decorator）意图为对象动态添加功能。 类图装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。 实现设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。 下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。 public interface Beverage &#123; double cost();&#125; public class DarkRoast implements Beverage &#123; @Override public double cost() &#123; return 1; &#125;&#125; public class HouseBlend implements Beverage &#123; @Override public double cost() &#123; return 1; &#125;&#125; public abstract class CondimentDecorator implements Beverage &#123; protected Beverage beverage;&#125; public class Milk extends CondimentDecorator &#123; public Milk(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public double cost() &#123; return 1 + beverage.cost(); &#125;&#125; public class Mocha extends CondimentDecorator &#123; public Mocha(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public double cost() &#123; return 1 + beverage.cost(); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Beverage beverage = new HouseBlend(); beverage = new Mocha(beverage); beverage = new Milk(beverage); System.out.println(beverage.cost()); &#125;&#125; 3.0 设计原则类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。 不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。 JDK java.io.BufferedInputStream(InputStream) java.io.DataInputStream(InputStream) java.io.BufferedOutputStream(OutputStream) java.util.zip.ZipOutputStream(OutputStream) java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap 5. 外观（Facade）意图提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。 类图 实现观看电影需要操作很多电器，使用外观模式可以实现一键看电影功能。 public class SubSystem &#123; public void turnOnTV() &#123; System.out.println(\"turnOnTV()\"); &#125; public void setCD(String cd) &#123; System.out.println(\"setCD( \" + cd + \" )\"); &#125; public void starWatching()&#123; System.out.println(\"starWatching()\"); &#125;&#125; public class Facade &#123; private SubSystem subSystem = new SubSystem(); public void watchMovie() &#123; subSystem.turnOnTV(); subSystem.setCD(\"a movie\"); subSystem.starWatching(); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Facade facade = new Facade(); facade.watchMovie(); &#125;&#125; 设计原则最少知识原则：只和你的密友谈话。也就是客户对象所需要交互的对象应当尽可能少。 6. 享元（Flyweight）意图利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。 类图 Flyweight：享元对象 IntrinsicState：内部状态，相同的项元对象共享 ExtrinsicState：外部状态 实现public interface Flyweight &#123; void doOperation(String extrinsicState);&#125; public class ConcreteFlyweight implements Flyweight &#123; private String intrinsicState; public ConcreteFlyweight(String intrinsicState) &#123; this.intrinsicState = intrinsicState; &#125; @Override public void doOperation(String extrinsicState) &#123; System.out.println(\"Object address: \" + System.identityHashCode(this)); System.out.println(\"IntrinsicState: \" + intrinsicState); System.out.println(\"ExtrinsicState: \" + extrinsicState); &#125;&#125; import java.util.HashMap;public class FlyweightFactory &#123; private HashMap&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;(); Flyweight getFlyweight(String intrinsicState) &#123; if (!flyweights.containsKey(intrinsicState)) &#123; Flyweight flyweight = new ConcreteFlyweight(intrinsicState); flyweights.put(intrinsicState, flyweight); &#125; return flyweights.get(intrinsicState); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; FlyweightFactory factory = new FlyweightFactory(); Flyweight flyweight1 = factory.getFlyweight(\"aa\"); Flyweight flyweight2 = factory.getFlyweight(\"aa\"); flyweight1.doOperation(\"x\"); flyweight2.doOperation(\"y\"); &#125;&#125; Object address: 1163157884IntrinsicState: aaExtrinsicState: xObject address: 1163157884IntrinsicState: aaExtrinsicState: y JDKJava 利用缓存来加速大量小对象的访问时间。 java.lang.Integer#valueOf(int) java.lang.Boolean#valueOf(boolean) java.lang.Byte#valueOf(byte) java.lang.Character#valueOf(char) 7. 代理（Proxy）意图控制对其它对象的访问。 类图代理有以下四类： 远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。 虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。 保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。 智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数，比如智能智能；当第一次引用一个持久化对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。 实现以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。 public interface Image &#123; void showImage();&#125; public class HighResolutionImage implements Image &#123; private URL imageURL; private long startTime; private int height; private int width; public int getHeight() &#123; return height; &#125; public int getWidth() &#123; return width; &#125; public HighResolutionImage(URL imageURL) &#123; this.imageURL = imageURL; this.startTime = System.currentTimeMillis(); this.width = 600; this.height = 600; &#125; public boolean isLoad() &#123; // 模拟图片加载，延迟 3s 加载完成 long endTime = System.currentTimeMillis(); return endTime - startTime &gt; 3000; &#125; @Override public void showImage() &#123; System.out.println(\"Real Image: \" + imageURL); &#125;&#125; public class ImageProxy implements Image &#123; private HighResolutionImage highResolutionImage; public ImageProxy(HighResolutionImage highResolutionImage) &#123; this.highResolutionImage = highResolutionImage; &#125; @Override public void showImage() &#123; while (!highResolutionImage.isLoad()) &#123; try &#123; System.out.println(\"Temp Image: \" + highResolutionImage.getWidth() + \" \" + highResolutionImage.getHeight()); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; highResolutionImage.showImage(); &#125;&#125; public class ImageViewer &#123; public static void main(String[] args) throws Exception &#123; String image = \"http://image.jpg\"; URL url = new URL(image); HighResolutionImage highResolutionImage = new HighResolutionImage(url); ImageProxy imageProxy = new ImageProxy(highResolutionImage); imageProxy.showImage(); &#125;&#125; JDK java.lang.reflect.Proxy RMI 参考资料 弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007. Gamma E. 设计模式: 可复用面向对象软件的基础 [M]. 机械工业出版社, 2007. Bloch J. Effective java[M]. Addison-Wesley Professional, 2017. Design Patterns Design patterns implemented in Java The breakdown of design patterns in JDK","categories":[{"name":"后端","slug":"back-end","permalink":"https://oneal.tech/categories/back-end/"}],"tags":[{"name":"Java设计模式","slug":"Java设计模式","permalink":"https://oneal.tech/tags/Java设计模式/"}]}]}