{"meta":{"title":"ONEAL.TECH","subtitle":"居安思危","description":"生活不止眼前的苟且,还有诗和远方的田野.","author":"O'Neal","url":"https://oneal.tech"},"pages":[{"title":"归档","date":"2018-07-21T08:23:07.000Z","updated":"2019-08-13T09:32:01.067Z","comments":false,"path":"archives/index.html","permalink":"https://oneal.tech/archives/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-08-13T09:32:01.067Z","updated":"2019-08-13T09:32:01.067Z","comments":true,"path":"tags/index.html","permalink":"https://oneal.tech/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"服务器推送","slug":"server-push","date":"2019-03-19T07:19:38.000Z","updated":"2019-08-13T09:32:01.067Z","comments":true,"path":"back-end/2019-03-19-server-push.html","link":"","permalink":"https://oneal.tech/back-end/2019-03-19-server-push.html","excerpt":"","text":"http协议介绍 http协议是请求/响应范式的，每个http 响应都对应一个 http 请求，http协议是无状态的，多个http请求之间是没有关系的； http协议的被动性，在标准的HTTP请求响应语义中，浏览器发起请求，服务器发送一个响应，这意味着在浏览器发起新请求前，服务器不能发送新信息给客户端浏览器； Ajax短轮询Ajax长论询SSE","categories":[{"name":"后端","slug":"back-end","permalink":"https://oneal.tech/categories/back-end/"}],"tags":[{"name":"Java服务器推送","slug":"Java服务器推送","permalink":"https://oneal.tech/tags/Java服务器推送/"}]},{"title":"Flutter Widget 目录","slug":"Flutter-Widget-menu","date":"2019-03-08T12:45:36.000Z","updated":"2019-08-13T09:32:01.067Z","comments":true,"path":"Flutter/2019-03-08-flutter-widget-menu.html","link":"","permalink":"https://oneal.tech/Flutter/2019-03-08-flutter-widget-menu.html","excerpt":"","text":"widget库扑组件框架使用方法：进口 package:flutter/widgets.dart 类AbsorbPointer在命中测试期间吸收指针的widget。[…] align一个widget，用于将其子项与其自身对齐，并根据子级的大小自行调整大小。[…] 对准矩形内的一个点。[…] AlignmentDirectional偏移量，表示为“ 大小”的一部分，但其水平分量取决于书写方向。[…] AlignmentGeometryAlignment的 基类，允许文本方向感知分辨率。[…] AlignmentGeometryTween两个AlignmentGeometry之间的插值。[…] AlignmentTween两个对齐之间的插值。[…] AlignTransitionAlign的 动画版本，可以为其Align.alignment属性设置动画。 AlwaysScrollableScrollPhysics滚动物理总是让用户滚动。[…] AlwaysStoppedAnimation 在给定值停止的动画[…] Animate&lt; T &gt;一个通过输入动画来生成类型为T的值的对象。[…] AnimatedAlignAlign的 动画版本，只要给定的对齐发生变化，就会在给定的持续时间内自动转换child的位置。[…] AnimatedBuilder用于构建动画的通用widget。[…] AnimatedContainer在一段时间内逐渐更改其值的容器。[…] AnimatedCrossFade一个widget，它在两个给定的子节点之间交叉淡化，并在它们的大小之间设置动画。[…] AnimatedDefaultTextStyle DefaultTextStyle的 动画版本，无论何时给定的样式发生更改，都会在给定的持续时间内自动转换默认文本样式（文本样式以应用于没有显式样式的后代Text widget）。[…] AnimatedList一个滚动容器，可在插入或移除项目时为其设置动画。[…] AnimatedListState滚动容器的状态，在插入或移除项目时为其设置动画。[…] AnimatedModalBarrier一个widget，可以防止用户与自身后面的widget交互，并且可以使用动画颜色值进行配置。[…] AnimatedOpacity不透明度的 动画版本，只要给定的不透明度发生变化，就会自动转换child在给定持续时间内的不透明度。[…] AnimatedPaddingPadding的 动画版本，无论何时给定的插入更改，它都会在给定的持续时间内自动转换缩进。[…] AnimatedPhysicalModelPhysicalModel的 动画版本。[…] AnimatedPositioned定位的 动画版本，可在给定位置发生变化时自动转换child在给定持续时间内的位置。[…] AnimatedPositionedDirectionalPositionedDirectional的 动画版本，可在给定位置发生变化时自动转换child在给定持续时间内的位置。[…] AnimatedSize动画窗口widget，只要给定子项的大小发生更改，就会在给定的持续时间内自动转换其大小。 AnimatedSwitcher默认情况下，窗口widget在新窗口widget和先前在AnimatedSwitcher上设置为窗口widget的窗口widget之间执行FadeTransition。[…] AnimatedWidget在给定的Listenable更改值时重建的窗口widget。[…] AnimatedWidgetBaseState &lt; T扩展了ImplicitlyAnimatedWidget &gt;具有隐式动画的widget的基类。[…] Animate&lt; T &gt;值为type的动画T。[…] AnimationController动画控制器。[…] AnimationEagerListenerMixin一个mixin用dispose契约替换didRegisterListener / didUnregisterListener契约。 AnimationLazyListenerMixinmixin仅在此对象已注册侦听器时帮助侦听另一个对象。 AnimationLocalListenersMixin一个mixin，它实现addListener / removeListener协议，并在调用notifyListeners时通知所有已注册的侦听器。 AnimationLocalStatusListenersMixin一个mixin，它实现addStatusListener / removeStatusListener协议，并在调用notifyStatusListeners时通知所有已注册的侦听器。 AnimationMax &lt; T extends num &gt;跟踪最多两个其他动画的动画。[…] AnimationMean双 s 的动画，跟踪其他两个动画的平均值。[…] AnimationMin &lt; T extends num &gt;跟踪最少两个其他动画的动画。[…] AnimationWithParentMixin &lt; T &gt;通过将其行为推迟到给定的父动画来 实现大多数动画界面。[…] ASPECTRATIO尝试将子项调整为特定宽高比的widget。[…] AssetBundleImageKey由AssetImage或ExactAssetImage获取的图像的键。[…] AssetBundleImageProviderImageProvider的 一个子类，它知道AssetBundle。[…] AssetImage从AssetBundle获取图像，根据上下文确定要使用的确切图像。[…] AsyncSnapshot &lt; T &gt;与异步计算的最新交互的不可变表示。[…] AutomaticKeepAlive允许子树请求在惰性列表中保持活动状态。[…] AutomaticKeepAliveClientMixin &lt; T扩展StatefulWidget &gt;为AutomaticKeepAlive的客户提供方便的方法。[…] BackdropFilter一个widget，它将过滤器应用于现有的绘制内容，然后绘制子项。[…] BallisticScrollActivity基于物理模拟动画滚动视图的活动。[…] 旗帜在另一个widget的角落上方显示对角线消息。[…] BannerPainter画横幅。底线根据child的基线定位child的widget。[…] BeveledRectangleBorder带有扁平或“斜角”角的矩形边框。[…] BlockSemantics一个窗口widget，它删除在同一个语义容器中绘制在其之前的所有窗口widget的语义。[…] 边境盒子的边框，由四个边组成：顶部，右侧，底部，左侧。[…] BorderDirectional盒子的边框，由四个边组成，其侧面基于读取方向翻转。[…] BorderRadius矩形每个角的一组不可变半径。[…] BorderRadiusDirectional矩形的每个角的一组不可变半径，但是角的指定方式取决于书写方向。[…] BorderRadiusGeometryBorderRadius的 基类，允许文本方向感知解析。[…] BorderRadiusTween两个BorderRadius之间的插值。[…] BorderSide盒子边框的一面。[…] BottomNavigationBarItem材质的BottomNavigationBar 或带有图标和标题的iOS主题CupertinoTabBar中的交互式按钮。[…] BouncingScrollPhysics滚动物理环境允许滚动偏移超出内容范围，但随后将内容反弹回这些边界的边缘。[…] BouncingScrollSimulation与iOS匹配的滚动物理实现。[…] BoxBorder框边框的基类，可以绘制为矩形，圆形或圆角矩形。[…] BoxConstraints不可变的布局约束RenderBox布局。[…] BoxConstraintsTween两个BoxConstraints之间的插值。[…] BoxDecoration关于如何绘制框的不可变描述。[…] BoxPainter一个有状态的类，可以绘制一个特定的装饰。[…] BoxScrollView一个滚动型采用单个子布局的模型。[…] BoxShadow由盒子投下的阴影。[…] BuildContext窗口widget树中窗口widget位置的句柄。[…] 生成器一个柏拉图窗口widget，它调用闭包来获取其子窗口widget。[…] BuildOwner窗口widget框架的管理器类。[…] 帆布用于记录图形操作的界面。[…] 中央一个小孩，它将child置于其中心。[…] ChangeNotifier可以扩展或混合的类，使用VoidCallback为通知提供更改通知API 。[…] CheckedModeBanner在已检查模式下运行时 显示标有“DEBUG” 的横幅。 MaterialApp默认构建其中一个。在发布模式下无效。 CircleBorder适合可用空间内圆圈的边框。[…] ClampingScrollPhysics滚动物理场以防止滚动偏移超出内容边界的环境。[…] ClampingScrollSimulation与Android匹配的滚动物理实现。[…] ClipOval使用椭圆剪辑其子项的widget。[…] ClipPath使用路径剪辑其子项的窗口widget。[…] ClipRect使用矩形剪辑其子项的widget。[…] ClipRRect使用圆角矩形剪辑其子项的窗口widget。[…] 颜色ARGB格式的不可变32位颜色值。[…] ColorFilter描述在绘制形状或使用特定Paint合成图层时应用的滤镜。滤色器是一种采用两种颜色并输出一种颜色的功能。在合成期间应用时，在整个图层与目标合并之前，它将独立应用于正在绘制的图层的每个像素。[…] ColorSwatch &lt; T &gt;一种颜色，有一个相关颜色的小表称为“样本”。[…] ColorTween两种颜色之间的插值。[…] 柱在垂直方向排列布局子控件的控件[…] ComponentElement一个元素是组成其他要素秒。[…] CompositedTransformFollower一个遵循CompositedTransformTarget的widget。[…] CompositedTransformTargetCompositedTransformFollower 可以定位的widget。[…] CompoundAnimation &lt; T &gt;用于组合多个动画的界面。子类只需要实现valuegetter来控制子动画的组合方式。可以链接组合2个以上的动画。[…] ConstrainedBox一个widget，对其子级施加其他约束。[…] 容器一个结合了常用的绘图组件，定位组件和尺寸组件的便捷组件。[…] 立方体单位区间的三次多项式映射。[…] 曲线单位间隔到单位间隔的映射。[…] CurvedAnimation将曲线应用于另一个动画的动画。[…] 曲线常见动画曲线的集合。[…] CurveTween通过给定曲线转换给定动画的值。[…] CustomClipper &lt; T &gt;用于提供自定义剪辑的界面。[…] CustomMultiChildLayout一个widget，它使用委托来调整和定位多个子节点。[…] CustomPaint的一个widget，提供在绘制阶段绘制的画布。[…] CustomPainter所用的接口CustomPaint的（在部件库）和 RenderCustomPaint（在绘制库）。[…] CustomPainterSemantics包含描述由CustomPaint使用的Canvas包含的矩形中绘制的信息的属性。[…] CustomScrollView一个滚动型创建使用棉条自定义滚动效果。[…] CustomSingleChildLayout一个widget，将其单个子级的布局推迟到委托。[…] DecoratedBox在儿童绘画之前或之后 绘制装饰的widget。[…] DecoratedBoxTransition动画版的DecoratedBox是其动画的不同属性装饰。[…] 装饰盒子装饰（应用于Rect的装饰）的描述。[…] DecorationImage箱子装饰的图象。[…] DecorationImagePainter装饰图像 的画家。[…] DecorationTween两个装饰之间的插值。[…] DefaultAssetBundle一个widget，用于确定其后代的默认资产包。[…] DefaultTextStyle要应用于后代Text widget而没有显式样式的文本样式。 DefaultWidgetsLocalizationswidget库的美国英语本地化版本。[…] 方向性用于确定文本和文本方向敏感渲染对象的环境方向性的窗口widget。[…] 可取消可以通过在指示的方向上拖动来解除的widget。[…] DragDownDetails使用GestureDragDownCallback的回调的详细信息对象。[…] DragEndDetails使用GestureDragEndCallback的回调的详细信息对象。[…] 可拖动&lt; T &gt;可以拖动到DragTarget的窗口widget。[…] DragScrollActivity滚动视图在用户在屏幕上拖动手指时执行的活动。[…] DragStartDetails使用GestureDragStartCallback的回调的详细信息对象。[…] DragTarget &lt; T &gt;删除Draggable widget 时接收数据的widget。[…] DragUpdateDetails使用GestureDragUpdateCallback的回调的详细信息对象。[…] DrivenScrollActivity基于动画参数设置动画滚动视图的活动。[…] EdgeInsets四个基本方向中每个方向的一组不可变的偏移量。[…] EdgeInsetsDirectional四个基本方向中的每个方向上的不可变的偏移集，但其水平分量取决于书写方向。[…] EdgeInsetsGeometryEdgeInsets的 基类，允许文本方向感知分辨率。[…] EdgeInsetsGeometryTween两个EdgeInsetsGeometry之间的插值。[…] EdgeInsetsTween两个EdgeInsets之间的插值。[…] EditableText基本文本输入字段。[…] EditableTextState声明EditableText的状态。 ElasticInCurve振荡曲线，在超出其范围的同时增大幅度。[…] ElasticInOutCurve一条振荡曲线，在超出其范围时会增大然后收缩。[…] ElasticOutCurve一条振荡曲线，在超出其范围时会缩小幅度。[…] 元件树中特定位置 的Widget实例化。[…] ErrorWidget呈现异常消息的widget。[…] ExactAssetImage从AssetBundle获取图像，将其与给定比例相关联。[…] ExcludeSemantics删除其后代的所有语义的widget。[…] 扩展一个使Row，Column或Flex的子控件扩展尺寸的控件。[…] FadeInImage在加载目标图像时显示占位符图像的图像，然后在加载时淡入新图像。[…] FadeTransition动画widget的不透明度。[…] FileImage将给定的File对象解码为图像，将其与给定的比例相关联。[…] FittedBox秤，并根据自身内部定位其子契合。[…] FittedSizesapplyBoxFit 返回的这对大小。 FixedColumnWidth将列的大小调整为特定数量的像素。[…] FixedExtentMetricsScrollPosition到具有固定项目大小的滚动视图的 度量标准。[…] FixedExtentScrollController用于滚动视图的控制器，其项目具有相同的大小。[…] FixedExtentScrollPhysics一种捕捉物理，它总是直接落在物品上而不是滚动范围内的任何地方。[…] FixedScrollMetrics与Scrollable视口关联的值的不可变快照。[…] 柔性在一维数组中显示其子项的窗口widget。[…] FlexColumnWidth在布置了所有其他列之后，通过占用剩余空间的一部分来确定列的大小。[…] 灵活控制行，列或Flex的子项如何弯曲的widget。[…] FlippedCurve曲线是其给定曲线的反转。[…] 流根据FlowDelegate中的逻辑，可以有效地调整和定位子项的widget。[…] FlowDelegate一个控制流布局外观的委托。[…] FlowPaintingContextFlowDelegate绘制的 上下文。[…] FlutterErrorDetails提供给FlutterExceptionHandler回调的信息的类。[…] FlutterLogoDecoration关于如何绘制Flutter徽标的不可变描述。的FocusManager管理焦点树。[…] FocusNode焦点树中可以接收焦点的叶节点。[…] FocusScope建立一个widget可以获得焦点的范围。[…] FocusScopeNode焦点树中的内部节点。[…] fontWeight设置用于绘制文本的字形的粗细形成用于将多个表单字段widget（例如TextField widget）分组在一起的可选容器。[…] FormField &lt; T &gt;单个表单字段。[…] FormFieldState &lt; T &gt;FormField 的当前状态。传递给FormFieldBuilder方法，用于构造表单字段的widget。 FormState与窗口widget关联的状态。[…] FractionallySizedBox一个widget，可将其子级调整为总可用空间的一小部分。有关布局算法的更多详细信息，请参阅 RenderFractionallySizedOverflowBox。[…] FractionalOffset偏移量，表示为大小的一部分。[…] FractionalOffsetTween两个小数偏移之间的插值。[…] FractionalTranslation在绘制其子项之前应用转换转换。[…] FractionColumnWidth将列的大小调整为表的约束’maxWidth的一小部分。[…] FutureBuilder &lt; T &gt;基于与Future交互的最新快照构建自己的widget。[…] GestureDetector检测手势的widget。[…] GestureRecognizerFactory &lt; T扩展了GestureRecognizer &gt;用于创建手势识别器的工厂。[…] GestureRecognizerFactoryWithHandlers &lt; T扩展了GestureRecognizer &gt;工厂用于创建委托给回调的手势识别器。[…] GlobalKey &lt; Ť延伸国&lt; StatefulWidget &gt; &gt;整个应用程序中唯一的密钥。[…] GlobalObjectKey &lt; Ť延伸国&lt; StatefulWidget &gt; &gt;一个全局键，从用作其值的对象获取其标识。[…] GlowingOverscrollIndicator滚动视图已过度滚动的可视指示。[…] 梯度2D渐变。[…] GridPaper一个widget，用于绘制一个像素宽的直线网格。[…] 网格视图可滚动的2Dwidget数组。[…] 英雄一个widget，标记其子级为英雄动画的候选者。[…] HeroController一个导航观察者管理英雄的转变。[…] HoldScrollActivity滚动活动，除了可以释放以恢复正常的空闲行为之外什么也不做。[…] HSVColor使用alpha，hue，饱和度和值表示的颜色。[…] 图标图形图标插件与来自于所述的字体的字形绘制IconData如材料的预定IconData以s 图标。[…] IconData字体标志符号表示的图标说明。[…] IconTheme控制窗口widget子树中图标的默认颜色，不透明度和大小。[…] IconThemeData定义图标的颜色，不透明度和大小。[…] IdleScrollActivity滚动活动，什么都不做。[…] IgnorePointer在命中测试期间不可见的widget。[…] 图片显示图像的widget。[…] ImageCache类为imageCache对象。[…] ImageConfiguration传递给ImageProvider.resolve方法的配置信息，用于选择特定图像。[…] 的ImageIcon来自ImageProvider的图标，例如AssetImage。[…] 的imageinfo一个dart：ui.Image对象及其对应的比例。[…] ImageProvider &lt; T &gt;识别图像而不提交精确的最终资产。这允许识别一组图像，并且稍后基于环境（例如，设备像素比）来解析精确图像。[…] ImageShader用于平铺图像的着色器（由Paint.shader使用）。 的ImageStream图像资源的句柄。[…] ImageStreamCompleter用于管理dart加载的基类：用于ImageStream的ui.Image对象 。[…] ImplicitlyAnimatedWidget用于构建窗口widget的抽象窗口widget，可在一段时间内逐渐更改其值。[…] IndexedStack一个堆栈，显示来自子项列表的单个子项。[…] InheritedElement使用InheritedWidget作为其配置 的Element。 InheritedWidgetwidget的基类，可以有效地在树中传播信息。[…] InspectorSelection检查员的可变选择状态。间隔曲线直到开始为0.0 ，然后弯曲（根据曲线从0.0到1.0 结束，然后是1.0。[…] IntrinsicColumnWidth根据该列中所有单元格的固有尺寸确定列的大小。[…] IntrinsicHeight一个widget，可以将其子级调整为子级的内在高度。[…] IntrinsicWidth一个widget，可以将其子级调整为子级的内部宽度。[…] IntTween两个整数之间的插值。[…] 活着标记一个child需要保持活着，即使它在一个懒惰的列表中，否则将删除它。[…] KeepAliveHandle甲收听其可以手动触发。[…] KeepAliveNotification指示此通知气泡必须保持活动的子树，即使它通常会作为优化被丢弃。[…] 键Key是Widget，Element和SemanticsNode的标识符[…] KeyedSubtree构建其子项的widget。[…] LabeledGlobalKey &lt; Ť延伸国&lt; StatefulWidget &gt; &gt;带调试标签的全局密钥。[…] LayerLinkLeaderLayer可以注册 的对象。[…] LayoutBuilder构建可依赖于父窗口widget大小的窗口widget树。[…] LayoutChangedNotification指示接收此通知的对象的其中一个后代的布局已经以某种方式更改，因此关于该布局的任何假设都不再有效。[…] LayoutId用于标识CustomMultiChildLayout中的子项的元数据。[…] LeafRenderObjectElement使用LeafRenderObjectWidget作为其配置 的Element。 LeafRenderObjectWidgetRenderObjectWidgets的超类，用于配置没有子项的RenderObject子类。 LimitedBox只有当它不受约束时才限制其大小的盒子。[…] 的LinearGradient2D线性渐变。[…] ListBody一个widget，它沿着给定的轴顺序排列它的子节点，强制它们到另一个轴的父节点的维度。[…] 可听维护侦听器列表的对象。 倾听者一个widget，它响应指针事件调用回调。[…] 列表显示可线性排列的widget可滚动列表。[…] ListWheelScrollView一个盒子，可以滚动轮子上的child。[…] ListWheelViewport显示轮子上的子集子集的视口。[…] 语言环境用于选择用户语言和格式首选项的标识符，由语言和国家/地区组成。这是BCP 47定义的区域设置标识符的子集。[…] LocalHistoryEntry LocalHistoryRoute 历史记录中的条目。 LocalHistoryRoute &lt; T &gt;可以通过弹出列表在内部处理返回导航的路由。[…] 本地化为其 定义区域设置child以及子项所依赖的本地化资源。[…] LocalizationsDelegate &lt; T &gt;用于一组本地化资源类型的工厂，T由Localizationswidget加载 。[…] LocalKey不是GlobalKey的关键[…] LongPressDraggable &lt; T &gt;从长按开始使其child可以拖拽。 MaskFilter一个蒙版过滤器，用于在绘制时应用于形状。掩码过滤器是一种采用彩色像素位图的函数，并返回另一个彩色像素位图。[…] Matrix44D矩阵。值以列主要顺序存储。 Matrix4Tween两个Matrix4之间的插值。[…] MatrixUtils用于处理矩阵的实用程序函数。 MaxColumnWidth确定列的大小，使其大小为两个列宽规范的最大值。[…] MediaQuery建立媒体查询解析给定数据的子树。[…] MediaQueryData有关介质的信息（例如，窗口）。[…] MemoryImage将给定的Uint8List缓冲区解码为图像，将其与给定的比例相关联。[…] MergeSemantics一个widget，它合并其后代的语义。[…] 元数据在渲染树中保存不透明的元数据。[…] MinColumnWidth确定列的大小，使其大小为两个列宽规范中的最小值。[…] ModalBarrier一个widget，阻止用户与自身后面的widget交互。[…] ModalRoute &lt; T &gt;阻止与先前路由交互的路由。[…] MultiChildLayoutDelegate一个控制多个子项布局的委托。[…] MultiChildRenderObjectElement使用MultiChildRenderObjectWidget作为其配置 的Element。[…] MultiChildRenderObjectWidget RenderObjectWidgets的超类，用于配置具有单个子项列表的RenderObject子类。（此超类仅为该子列表提供存储，它实际上不提供更新逻辑。） MultiFrameImageStreamCompleter管理图像帧的解码和调度。[…] NavigationToolbarNavigationToolbar是一个布局助手，用于沿水平轴定位3个widget或widget组，这对于应用程序的导航栏是合理的，例如在Material Design和iOS中。[…] 航海家一个widget，用于管理具有堆栈规则的一组子widget。[…] NavigatorObserver用于观察导航器行为的界面。 NavigatorStateNavigator widget 的状态。 NestedScrollView其中的滚动视图可以嵌套其他滚动视图，其滚动位置本质上是链接的。[…] NestedScrollViewViewportNestedScrollView使用 的Viewport变体。[…] NetworkImage从网络获取给定的URL，将其与给定的比例相关联。[…] NeverScrollableScrollPhysics滚动物理，不允许用户滚动。[…] 通知可以冒泡widget树的通知。[…]NotificationListener &lt; T extends Notification &gt;一个widget，用于侦听通知冒泡树。[…]ObjectKey从用作其值的对象获取其标识的键。[…]抵消不可变的2D浮点偏移量。[…]台下一个widget，它将child放在树中，但没有绘制任何东西，没有让child可用于命中测试，也没有占用父母的任何空间。[…] OneFrameImageStreamCompleter管理dart：ui.Image对象的加载，用于静态ImageStream（只有一帧）。 不透明度使子项部分透明的widget。[…] OrientationBuilder构建可依赖于父窗口widget方向的窗口widget树（与设备方向不同）。[…] OverflowBox一个widget，它对子进程施加的约束不同于从其父进程获得的约束，可能允许子进程溢出父进程。[…] 覆盖一个堆栈条目可以独立进行管理。[…] OverlayEntry在一个地方叠加，可以包含一个widget。[…] OverlayRoute &lt; T &gt;在导航器的叠加层中显示窗口widget的路径。 OverlayStateOverlay 的当前状态。[…] OverscrollIndicatorNotificationGlowingOverscrollIndicator将开始显示过度滚动指示的 通知。[…] OverscrollNotification通知Scrollable widget未更改其滚动位置，因为更改会导致其滚动位置超出其滚动边界。[…] 填充一个widget，通过给定的填充来保护其子级。[…] 的PageControllerPageView 的控制器。[…] PageMetricsPageView的 度量标准。[…] PageRoute &lt; T &gt;替换整个屏幕的模态路线。 PageRouteBuilder &lt; T &gt;用于根据回调定义一次性页面路由的实用程序类。[…] PageScrollPhysics滚动由使用物理浏览量。[…] PageStorage为此窗口widget子树建立页面存储桶的窗口widget。 PageStorageBucket与应用中的页面关联的存储桶。[…] PageStorageKey &lt; T &gt;一个ValueKey用于定义PageStorage值将被保存。[…] 页面预览可逐页工作的可滚动列表。[…] 涂料在画布上绘制时使用的样式的说明。[…] PaintingBinding绑定绘画库。[…] PaintingContext一个画画的地方。[…] ParentDataElement &lt; T扩展RenderObjectWidget &gt;使用ParentDataWidget作为其配置 的Element。 ParentDataWidget &lt; T扩展RenderObjectWidget &gt;将ParentData信息挂接到RenderObjectWidget的子 节点的widget的基类。[…] 路径平面的复杂一维子集。[…] PerformanceOverlay显示性能统计信息 […] PhysicalModel表示将其子项剪辑为形状的物理层的窗口widget。[…] PhysicalShape一个widget，表示将其子级剪辑为路径的物理层。[…] 占位符一个widget，用于绘制一个框，表示有一天会添加其他widget的位置。[…] PointerCancelEvent指针的输入不再指向此接收器。 PointerDownEvent指针已与设备联系。 PointerEvent触摸，手写笔或鼠标事件的基类。[…] PointerMoveEvent当指针与设备接触时，指针相对于设备移动。[…] PointerUpEvent指针已停止与设备联系。 PopupRoute &lt; T &gt;在当前路线上覆盖窗口widget的模态路径。 定位一个控件，用于控制堆栈子项的位置。[…] PositionedDirectional一个widget，用于控制堆栈子项的位置，而不需要提交特定的TextDirection。[…] PositionedTransition定位的 动画版本，它采用特定的 动画在动画的生命周期内将child的位置从起始位置转换到结束位置。[…] PREFERREDSIZE具有首选大小的widget。[…] PreferredSizeWidget窗口widget的接口，如果不受约束，则可以返回此窗口widget所希望的大小。[…] PrimaryScrollController将ScrollController与子树关联。[…] ProxyAnimation作为另一个动画的代理的动画。[…] ProxyElement使用ProxyWidget作为其配置 的Element。 ProxyWidget提供了子窗口widget的窗口widget，而不是构建新窗口widget。[…] 的RadialGradient2D径向渐变。[…] 半径圆形或椭圆形的半径。 RawGestureDetector一个widget，用于检测给定手势工厂描述的手势。[…] RawGestureDetectorState国家对RawGestureDetector。 RawImage一个直接显示dart：ui.Image的widget。[…] RawKeyboardListener每当用户按下或释放键盘上的键时调用回调的widget。[…] RawKeyEvent原始密钥事件的基类。[…] 矩形一个不可变的，2D，轴对齐的浮点矩形，其坐标相对于给定的原点。[…] RectTween两个矩形之间的插值。[…] RelativePositionedTransitionPositioned的 动画版本，它根据相对于具有指定大小的边界框的rect值转换子项的位置。[…] RelativeRect一个不可变的2D，轴对齐的浮点矩形，其坐标相对于另一个矩形的边缘给出，称为容器。由于矩形的尺寸是相对于容器的尺寸，因此该类没有宽度和高度成员。为了确定矩形的宽度或高度，将其转换为一个矩形使用toRect（） （通过容器本身的矩形），然后检查该对象。[…] RelativeRectTween两个相对rects之间的插值。[…] RenderBox2D笛卡尔坐标系中的渲染对象。[…] RenderNestedScrollViewViewportNestedScrollView使用 的RenderViewport变体。[…] 渲染对象渲染树中的对象。[…] RenderObjectElement使用RenderObjectWidget作为其配置 的Element。[…] RenderObjectToWidgetAdapter &lt; T扩展RenderObject &gt;从RenderObject到Element树的桥梁。[…] RenderObjectToWidgetElement &lt; T扩展RenderObject &gt;由RenderObject托管的RootRenderObjectElement。[…] RenderObjectWidgetRenderObjectWidgets提供用于配置RenderObjectElement s，这涡卷渲染对象 s，这提供了应用程序的实际渲染。 RenderSliv​​erOverlapAbsorber包裹另一个的条子，迫使其布局范围被视为重叠。[…] RenderSliv​​erOverlapInjector基于存储在SliverOverlapAbsorberHandle中的值具有条子几何形状的条子 。[…] RepaintBoundary一个widget，为其子级创建单独的显示列表。[…] ReverseAnimation与另一个动画相反的动画。[…] ReverseTween &lt; T &gt;一个Tween，反向评估其父级。 富文本一段富文本。[…] RootRenderObjectElement树根处的元素。[…] RotatedBox一个widget，可以将其子项旋转整数个四分之一圈。[…] RotationTransition动画widget的旋转。 RoundedRectangleBorder带圆角的矩形边框。[…] 路线&lt; T &gt;由导航器管理的条目的抽象。[…]RouteAware知道其当前Route的对象的接口。[…]RouteObserver &lt; R extends Route &gt;一个导航观察者通知RouteAware变化s到他们的状态路线。[…]RouteSettings可能在构建路径时有用的数据。行使子控件横向排列显示的控件。[…]RRect一个不可变的圆角矩形，具有所有四个角的自定义半径。RSTransform由平移，旋转和均匀比例组成的变换。[…]SafeArea一个widget，通过足够的填充来保护其子级，以避免操作系统的入侵。[…]锯齿锯齿曲线，在单位间隔内重复给定次数。[…] ScaleEndDetails有关GestureScaleEndCallback的详细信息。 ScaleStartDetails有关GestureScaleStartCallback的详细信息。 ScaleTransition动画转换widget的比例。 ScaleUpdateDetails有关GestureScaleUpdateCallback的详细信息。 滚动滚动的widget。[…] ScrollableStateScrollable widget的 State对象。[…] ScrollActivity用于滚动活动（如拖动和投掷）的基类。[…] ScrollActivityDelegateScrollActivity 的后端。[…] ScrollbarPainter用于绘制滚动条 的CustomPainter。[…] ScrollBehavior描述可滚动窗口widget的行为方式。[…] ScrollConfiguration控制可滚动窗口widget在子树中的行为方式。[…] ScrollContextScrollable widget实现 的接口，以便使用 ScrollPosition。[…] ScrollController控制可滚动的widget。[…] ScrollDragController当用户在屏幕上拖动手指时滚动滚动视图。[…] ScrollEndNotificationScrollable widget已停止滚动的 通知。[…] ScrollHoldController用于保持Scrollable静止的接口。[…] ScrollMetricsScrollable内容的 描述，用于建模视口的状态。[…] ScrollNotification与滚动相关 的通知。[…] ScrollPhysics确定Scrollable widget的物理特性。[…] 的scrollPosition确定滚动视图中可见的内容部分。[…] ScrollPositionWithSingleContext滚动位置，用于管理单个ScrollContext的滚动活动 。[…] ScrollSpringSimulation一个SpringSimulation，其中x的值保证在模拟isDone（）时具有完全最终值。 ScrollStartNotificationScrollable widget已开始滚动的 通知。[…] ScrollUpdateNotificationScrollable widget已更改其滚动位置的 通知。[…] 滚动型滚动的widget。[…] 语义一个widget，用widget含义的描述来注释widget树。[…] SemanticsDebugger一个可视化child语义的widget。[…] 着色器Gradient和ImageShader 等对象的基类，它们对应于Paint.shader使用的着色器。 ShaderMask一个widget，它将Shader生成的遮罩应用于其子级。[…] ShapeBorder形状轮廓的基类。[…] ShapeDecoration关于如何绘制任意形状的不可变描述。[…] ShrinkWrappingViewport内部较大的widget，收缩包装在主轴上的子项。[…] 模拟所有模拟的基类。[…] SingleChildLayoutDelegate用于计算具有单个子项的渲染对象的布局的委托。[…] SingleChildRenderObjectElement使用SingleChildRenderObjectWidget作为其配置 的Element。[…] SingleChildRenderObjectWidgetRenderObjectWidgets的超类，用于配置具有单个子槽的RenderObject子类。（此超类仅为该子级提供存储，它实际上不提供更新逻辑。） SingleChildScrollView可以滚动单个窗口widget的框。[…] SingleTickerProviderStateMixin &lt; T扩展StatefulWidget &gt;提供单个Ticker，配置为仅在启用当前树时打勾，如TickerMode所定义。[…] 尺寸保持2D浮点大小。[…] SizeChangedLayoutNotification指示接收此通知的对象的其中一个后代的大小已更改，因此有关该布局的任何假设都不再有效。[…] SizeChangedLayoutNotifier一个widget， 当其子级的布局维度发生更改时自动调度SizeChangedLayoutNotification。[…]SizedBox 具有指定大小的框。[…] SizedOverflowBox一个特定大小的窗口widget，但将其原始约束传递给其子节点，然后可能会溢出。[…] SizeTransition动画自己的大小和剪辑并对齐child。[…] SizeTween两种尺寸之间的插值。[…] SlideTransition动画widget相对于其正常位置的位置。[…] SliverChildBuilderDelegate使用构建器回调为子项提供子项的委托。[…] SliverChildDelegate为儿童提供条子的代表。[…] SliverChildListDelegate使用明确列表为儿童提供儿童的代表。[…] SliverFillRemaining包含单个框子项的条子，填充视口中的剩余空间。[…] SliverFillViewport包含多个子框的子条，每个子框填充视口。[…] SliverFixedExtentList将多个具有相同主轴范围的盒子项放置在线性阵列中的条子。[…] SliverGrid将多个盒子儿童放置在二维排列中的条子。[…] SliverGridDelegate控制网格中图块的布局。[…] SliverGridDelegateWithFixedCrossAxisCount创建横轴中具有固定数量的切片的网格布局。[…] SliverGridDelegateWithMaxCrossAxisExtent使用每个都具有最大横轴范围的切片创建网格布局。[…] SliverList沿着主轴将多个盒子放置在线性阵列中的条子。[…] SliverMultiBoxAdaptorElement一个懒惰地为SliverMultiBoxAdaptorWidget构建子元素的元素。[…] SliverMultiBoxAdaptorWidget条子的基类，有多个盒子元素。[…] SliverOverlapAbsorber包裹另一个的条子，迫使其布局范围被视为重叠。[…] SliverOverlapAbsorberHandle提供给SliverOverlapAbsorber，SliverOverlapInjector和NestedScrollViewViewport的句柄，用于在NestedScrollView中移位重叠。[…] SliverOverlapInjector基于存储在SliverOverlapAbsorberHandle中的值具有条子几何形状的条子 。[…] SliverPadding在另一条棉条的每一侧都应用衬垫的条子。[…] SliverPersistentHeader当条子滚动到视口的前缘时，尺寸​​变化的条子。[…] SliverPersistentHeaderDelegate委派配置SliverPersistentHeader。 SliverPrototypeExtentList将盒子放置在线性阵列中并将它们限制为沿主轴具有与原型项相同程度的条子。[…] SliverSafeArea通过足够的填充来插入另一条条子的条子，以避免操作系统的入侵。[…] SliverToBoxAdapter包含单个框widget的条子。[…]堆一个widget，用于将其子级相对于其框的边缘定位。[…] StadiumBorder一个边框，适合体育场形状的边框（两端有半圆形的框），适用于它所应用的widget的矩形。[…] State &lt; T扩展StatefulWidget &gt;StatefulWidget 的逻辑和内部状态。[…] StatefulBuilder一个柏拉图窗口widget，它们都具有状态并调用闭包来获取其子窗口widget。[…] StatefulElement使用StatefulWidget作为其配置 的Element。 StatefulWidget具有可变状态的widget。[…] StatelessElement使用StatelessWidget作为其配置 的Element。 StatelessWidget一个不需要可变状态的widget。[…] StatusTransitionWidget在给定动画更改状态时重建的窗口widget。 StepTween地板之间的两个整数之间的插值。[…] StreamBuilder &lt; T &gt;基于与Stream交互的最新快照构建自身的小组件。[…] StreamBuilderBase &lt; T，S &gt;基于与指定Stream的交互构建自己的widget的基类。[…] 表为其子项使用表布局算法的窗口widget。[…] 表格边框表格widget的 边框规范。[…] TableCell的一个widget，用于控制表的子节点的对齐方式。[…] TableColumnWidth用于描述RenderTable中列的宽度的基类。[…] 的TableRow表 中的一组水平单元格。[…] TapDownDetails有关GestureTapDownCallback的详细信息，例如位置。 TapUpDetails有关GestureTapUpCallback的详细信息，例如位置。 文本一系列具有单一样式的文本。[…] 文本框包含一段文本的矩形。[…] TextDecoration在文本附近绘制的线性装饰。 TextEditingController用于可编辑文本字段的控制器。[…] TextEditingValue用于编辑文本行的当前文本，选择和撰写状态。 TextInputType要优化文本输入控件的信息类型。[…] TextPainter将TextSpan树绘制到Canvas中的对象。[…] TextPosition文本字符串中的视觉位置。 的TextRange一串文本中的一系列字符。 TextSelection表示选择的一系列文本。 TextSelectionControls用于构建选择UI的界面，由工具栏widget的实现者提供。[…] TextSelectionDelegate用于操作选择的界面，供工具栏widget的实现者使用。 TextSelectionOverlay管理一对文本选择句柄的对象。[…] TextSpan不可变的文本范围。[…] 文字样式一种不可变的样式，其中绘制文本。[…] TextStyleTween两个TextStyle之间的插值。[…] 质地一个矩形，后端纹理映射在该矩形上。[…] 阈曲线为0.0，直到达到阈值，然后跳到1.0。[…] TickerFuture表示正在进行的Ticker序列的对象。[…] TickerMode启用或禁用窗口widget子树中的代码（以及动画控制器）。[…] TickerProvider由可以销售Ticker对象的类实现的接口。[…] TickerProviderStateMixin &lt; T扩展StatefulWidget &gt;提供Ticker对象，这些对象配置为仅在启用当前树时打勾，如TickerMode所定义。[…] 标题在操作系统中描述此应用程序的widget。 公差指定距离，持续时间和速度差异的最大允许幅度的结构被认为是相等的。 TrackingScrollController一个ScrollController，其initialScrollOffset跟踪其最近更新的ScrollPosition。[…] TrainHoppingAnimation此动画通过代理一个动画开始，但可以给出第二个动画。当他们的时间交叉时（或者因为第二个是相反的方向，或者因为一个超过另一个），动画会跳到代理第二个动画，第二个动画成为新的“第一”动画。[…] 转变在绘制其子项之前应用转换的窗口widget。[…] TransformProperty处理表示变换的Matrix4的属性。 TransitionRoute &lt; T &gt;具有入口和出口过渡的路线。 Tween &lt; T扩展动态 &gt;开始值和结束值之间的线性插值。[…] TypeMatcher &lt; T &gt;此类是“is”运算符的解决方法，它不接受变量值作为其右操作数 UnconstrainedBox一个widget，它对子节点没有约束，允许它以“自然”大小呈现。[…] 唯一键一个只与自己相等的关键。 UniqueWidget &lt; Ť延伸国&lt; StatefulWidget &gt; &gt;有状态窗口widget的基类，它在树中只有一个膨胀的实例。[…] UserScrollNotification用户已更改滚动方向的通知。[…] ValueKey &lt; T &gt;使用特定类型的值来标识自身的钥匙。[…] ValueNotifier &lt; T &gt;甲ChangeNotifier保存单个值。[…] 速度二维速度。 视口内部更大的widget。[…] ViewportNotificationMixinMixin for Notification用于跟踪他们已经通过的RenderAbstractViewport的数量。[…] 窗口widget用于描述元素的配置[…] WidgetInspector一个widget，可以检查子widget的结构。[…] WidgetInspectorServiceGUI工具用于与WidgetInspector交互的服务。[…] WidgetsApp一个便利类，它包含了应用程序通常需要的许多widget。[…] WidgetsBindingwidget层和Flutter引擎之间的粘合剂。 WidgetsBindingObserver使用Widgets图层绑定注册的类的接口。[…] WidgetsFlutterBinding基于Widgets框架的应用程序的具体绑定。这是将框架绑定到Flutter引擎的粘合剂。 WidgetsLocalizations用于最低级别的Flutter框架的本地化资源值的接口。[…] WidgetToRenderBoxAdapter用于在窗口widget树中放置特定RenderBox的适配器。[…] WillPopScope注册回调以否决用户尝试解除封闭的 ModalRoute。[…] 包一个widget，以多个水平或垂直运行方式显示其子项。[…] 常量kAlwaysCompleteAnimation →const 动画&lt; double &gt;一个总是完整的动画。[…] const _AlwaysCompleteAnimation()kAlwaysDismissedAnimation →const 动画&lt; double &gt;一个总是被解雇的动画。[…]const _AlwaysDismissedAnimation() 属性debugHighlightDeprecatedWidgets ↔ 布尔显示已弃用的widget的横幅。 读/写debugPrint ↔ DebugPrintCallback将消息打印到控制台，您可以使用“flutter”工具的“logs”命令（“flutter logs”）访问该控制台。[…] 读/写debugPrintBuildScope ↔ 布尔记录所有来电BuildOwner.buildScope。[…] 读/写debugPrintGlobalKeyedWidgetLifecycle ↔ 布尔在取消激活具有全局键的窗口widget时记录，并在重新激活（重新记录）时记录。[…] 读/写debugPrintRebuildDirtyWidgets ↔ 布尔记录每帧构建的脏widget。[…] 读/写debugPrintScheduleBuildForStacks ↔ 布尔记录将widget标记为需要重建的调用堆栈。[…] 读/写debugProfileBuildsEnabled ↔ 布尔Timeline为每个构建的Widget 添加事件。[…]读/写imageCache → ImageCache实现Flutter框架图像缓存的单例。[…] 只读函数applyBoxFit（BoxFit fit， Size inputSize， Size outputSize） → FittedSizes应用BoxFit值。[…] axisDirectionIsReversed（AxisDirection axisDirection） → bool返回沿给定轴方向行进是否以数字递减顺序访问沿该轴的坐标。[…] axisDirectionToAxis（AxisDirection axisDirection） → 轴返回包含给定AxisDirection的Axis。[…] createLocalImageConfiguration（BuildContext context，{ Size size }） → ImageConfiguration基于给定的BuildContext（以及可选的大小） 创建ImageConfiguration。[…] debugAssertAllWidgetVarsUnset（String reason） → bool如果未更改任何窗口widget库调试变量，则返回true。[…] debugCheckHasDirectionality（BuildContext context） → bool断言给定的上下文具有Directionality祖先。[…] debugCheckHasMediaQuery（BuildContext context） → bool断言给定上下文具有MediaQuery祖先。[…] debugCheckHasTable（BuildContext context） → bool断言给定上下文具有表祖先。[…] debugChildrenHaveDuplicateKeys（Widget parent， Iterable &lt; Widget &gt; children） → bool如果给定子列表包含任何重复的非null键，则置位。[…] debugDescribeTransform（Matrix4 transform） → List &lt; String &gt;以对TransformProperty有用的格式返回表示给定转换的字符串列表。[…] debugDumpApp（） →void打印当前正在运行的应用程序的字符串表示。 debugDumpLayerTree（） →void打印整个图层树的文本表示。 debugDumpRenderTree（） →void打印整个渲染树的文本表示。 debugItemsHaveDuplicateKeys（Iterable &lt; Widget &gt; items） → bool如果给定的项列表包含任何重复的非空键，则断言。[…] debugPrintStack（{ String label， int maxFrames }） →void使用debugPrint和 FlutterError.defaultStackFilter将当前堆栈转储到控制台。[…] debugWidgetBuilderValue（Widget小 部件， Widget 内置） →void断言built widget不为空。[…] decodeImageFromList（Uint8List list） → Future &lt; Image &gt;从字节列表创建图像。[…] defaultScrollNotificationPredicate（ScrollNotification notification） → bool一个ScrollNotificationPredicate，它检查是否 notification.depth == 0，这意味着通知没有通过任何插入的滚动widget。flipAxis（轴 方向） → 轴返回给定轴的反面。[…] flipAxisDirection（AxisDirection axisDirection） → AxisDirection返回给定AxisDirection的反向。[…] getAxisDirectionFromAxisReverseAndDirectionality（BuildContext context， Axis axis， bool reverse） → AxisDirection返回当前Directionality中给定Axis中 的AxisDirection（或反之，如果为true）。[…] reversehashList（Iterable &lt; Object &gt; arguments） → int将Iterable中任意数量对象 的Object.hashCode值合并为一个值。如果给定null，则此函数将返回相同的值，就像给出一个空列表一样。hashValues（Object arg01， Object arg02，[ Object arg03 = _hashEnd， Object arg04 = _hashEnd， Object arg05 = _hashEnd， Object arg06 = _hashEnd， Object arg07 = _hashEnd， Object arg08 = _hashEnd， Object arg09 = _hashEnd， Object arg10 = _hashEnd， 对象 arg11 = _hashEnd， 对象 arg12 = _hashEnd， 对象 arg13 = _hashEnd， 对象 arg14 = _hashEnd， 对象 arg15 = _hashEnd， 对象 arg16 = _hashEnd， 对象 arg17 = _hashEnd， 对象 arg18 = _hashEnd， 对象 arg19 = _hashEnd， 对象 arg20 =_hashEnd ]） → int将最多20个对象的哈希码组合成一个值。[…] paintBorder（Canvas canvas， Rect rect，{ BorderSide top：BorderSide.none， BorderSide right：BorderSide.none， BorderSide bottom：BorderSide.none， BorderSide left：BorderSide.none }） →void在画布上绘制给定矩形周围的边框。[…] paintImage（{ Canvas canvas， Rect rect， Image image， ColorFilter colorFilter， BoxFit fit， Alignment alignment：Alignment.center， Rect centerSlice， ImageRepeat repeat：ImageRepeat.noRepeat， bool flipHorizo​​ntally：false }） →void将图像绘制到画布上的给定矩形中。[…] paintZigZag（画布 画布， 油漆 颜料， 偏移 开始， 偏移 结束， int zigs， 双倍 宽度） →void在两点之间画一条线，在连接两点的线上对角线前后切割。[…] positionDependentBox（{ Size size， Size childSize， Offset target， bool preferBelow， double verticalOffset：0.0， double margin：10.0 }） → Offset将子框放在容器框内，位于目标点的上方或下方。[…] precacheImage（ImageProvider 提供程序， BuildContext 上下文，{ Size size }） → Future &lt; Null &gt;将图像预取到图像缓存中。[…] runApp（widget 应用程序） →无效给给定的widget充气并将其附加到屏幕上。[…] textDirectionToAxisDirection（TextDirection textDirection） → AxisDirection返回在给定TextDirection中进行读取的AxisDirection。[…] 枚举AnimationStatus 动画的状态AppLifecycleState申请可以进入的国家。[…] 轴两个方面的两个基本方向。[…] AxisDirection沿水平轴或垂直轴的方向。 BannerLocation在哪里展示横幅。[…] 混合模式在画布上绘画时使用的算法。[…] BlurStyle用于MaskFilter对象中模糊的样式。 边框在边框中 为BorderSide绘制的线条样式。 BoxFit如何将盒子刻在另一个盒子里。[…] BoxShape渲染Border或BoxDecoration时使用的形状。[…] ConnectionState与异步计算的连接状态。[…] CrossAxisAlignment如何将儿童沿横轴放置在柔性布局中。[…] CrossFadeState指定要显示的两个子项中的哪一个。请参阅AnimatedCrossFade。[…] DecorationPosition在哪里画一个盒子装饰。 DiagnosticLevel用于过滤显示和省略哪些诊断的各种优先级。[…] DismissDirection可以驳回不予受理 的方向。 DragAnchor凡可拖动应在拖动过程中被锚定。 FadeInImagePhaseFadeInImage经历 的阶段。 FilterQuality图像过滤器的质量级别。[…] FLEXFIT如何将child铭刻在可用空间内。[…] FlutterLogoStyle绘制Flutter徽标的可能方法。 字体样式是否在字体中倾斜字形 GrowthDirection相对于滚动偏移轴，条子内容的排序方向。[…] HitTestBehavior在命中测试期间如何表现。 ImageRepeat如何绘制未被图像覆盖的框的任何部分。 MainAxisAlignment如何在柔性布局中沿着主轴放置子项。[…] MainAxisSize主轴应占用多少空间。[…] 方向无论是纵向还是横向。 溢出是否应该剪掉溢出的child，或者看到他们的溢出。 PaintingStyle在画布上绘制形状和路径的策略。[…] PathFillType确定决定如何计算Path内部的缠绕规则。[…] RenderComparison两个对象之间差异的描述，在它将如何影响渲染的上下文中。[…] RoutePopDisposition指示是否应弹出当前路由。[…] SelectionChangedCause指示触发所选文本更改的内容（包括对光标位置的更改）。 StackFit如何调整Stack的未定位子项的大小。[…] StrokeCap用于行结尾的样式。[…] StrokeJoin用于线连接的样式。[…] TableCellVerticalAlignmentRenderTable对象中 单元格的垂直对齐选项。[…] 上投放用户交互应适应目标的平台。[…] TextAffinity是否TextPosition是视觉上的上游或其偏移的下游。[…] textAlign设置是否以及如何水平对齐文本。 TextBaseline用于对齐文本的水平线。 TextDecorationStyle绘制文本装饰的样式 TextDirection文本流动的方向。[…] TextOverflow如何处理溢出的文本。 TextSelectionHandleType要显示哪种类型的选择句柄。[…] TILEMODE定义渐变边缘发生的事情。[…] VertexMode定义在绘制一组三角形时如何解释点列表。[…] VerticalDirection盒子垂直流动的方向。[…] WrapAlignmentWrap 如何对齐对象。[…] WrapCrossAlignment谁包裹应该在横轴的运行中对齐儿童。 类型定义AnimatedCrossFadeBuilder（Widget topChild， Key topChildKey， Widget bottomChild， Key bottomChildKey） → Widget签名AnimatedCrossFade.layoutBuilder回拨。[…] AnimatedListItemBuilder（BuildContext context， int index， Animation &lt; double &gt; animation） → Widget使用的构建器回调的签名AnimatedList。 AnimatedListRemovedItemBuilder（BuildContext context， Animation &lt; double &gt; animation） → Widget使用的构建器回调的签名AnimatedListState.removeItem。 AnimatedSwitcherLayoutBuilder（List &lt; Widget &gt; children） → Widget用于生成自定义布局的构建器的签名 AnimatedSwitcher。[…] AnimatedSwitcherTransitionBuilder（Widget child， Animation &lt; double &gt; animation） → Widget用于生成自定义转换的构建器的签名 AnimatedSwitcher。[…] AnimationStatusListener（AnimationStatus status） →无效使用附加的听众签名Animation.addStatusListener。 AsyncWidgetBuilder &lt; T &gt; （BuildContext context， AsyncSnapshot &lt; T &gt; snapshot） → Widget签名用于基于异步交互构建widget的策略。[…] CreateRectTween（Rect begin， Rect end） → Tween &lt; Rect &gt;一个函数的签名，它接受两个Rect实例并返回 RectTween它们之间的转换。[…] DismissDirectionCallback（DismissDirection direction） →void使用的签名Dismissible表示已在给定的情况下被解雇direction。[…] DraggableCanceledCallback（速度 速度， 偏移 偏移） →无效在Draggable没有被a接受的情况下丢弃a的签名DragTarget。[…] DragTargetAccept &lt; T &gt; （T 数据） →无效用于使a DragTarget接受给定数据的签名。[…] DragTargetBuilder &lt; T &gt; （BuildContext context， List &lt; T &gt; candidateData， List rejectedData） → Widget建立儿童的签名DragTarget。[…] DragTargetLeave &lt; T &gt; （T 数据） →无效Draggable离开 时签名DragTarget。[…] DragTargetWillAccept &lt; T &gt; （T 数据） → bool用于确定给定数据是否将被a接受的签名DragTarget。[…] ElementVisitor（元素 元素） →无效签名回拨给BuildContext.visitChildElements。[…] ErrorWidgetBuilder（FlutterErrorDetails 详细信息） → Widget构建窗口widget时发生错误时调用的构造函数的签名。[…] FormFieldBuilder &lt; T &gt; （FormFieldState &lt; T &gt; 字段） → Widget用于构建表示表单字段的窗口widget的签名。[…] FormFieldSetter &lt; T &gt; （T newValue） →无效签名，以便在表单字段更改值时收到通知。[…] FormFieldValidator &lt; T &gt; （T 值） → 字符串用于验证表单字段的签名。[…] GenerateAppTitle（BuildContext context） → String签名WidgetsApp.onGenerateTitle。[…] GestureDragCancelCallback（） →无效当先前触发的指针GestureDragDownCallback未完成时的签名 。[…] GestureDragDownCallback（DragDownDetails 详细信息） →void当指针接触屏幕并可能开始移动时的签名。[…] GestureDragEndCallback（DragEndDetails 详细信息） →void当先前与屏幕接触并且移动的指针不再与屏幕接触时的签名。[…] GestureDragStartCallback（DragStartDetails 详细信息） →void指针接触屏幕并开始移动时的签名。[…] GestureDragUpdateCallback（DragUpdateDetails 详细信息） →void当与屏幕接触并且移动的指针再次移动时签名。[…] GestureLongPressCallback（） →无效当指针长时间保持与同一位置的屏幕保持接触时的签名。 GestureRecognizerFactoryConstructor &lt; T扩展GestureRecognizer &gt; （） →T签名用于实现的闭包GestureRecognizerFactory.constructor。 GestureRecognizerFactoryInitializer &lt; T扩展GestureRecognizer &gt; （T 实例） →无效签名用于实现的闭包GestureRecognizerFactory.initializer。 GestureScaleEndCallback（ScaleEndDetails 详细信息） →无效当指针不再与屏幕接触时的签名。 GestureScaleStartCallback（ScaleStartDetails 详细信息） →无效当与屏幕接触的指针建立焦点并且初始比例为1.0时的签名。 GestureScaleUpdateCallback（ScaleUpdateDetails 详细信息） →无效当与屏幕接触的指针指示新的焦点和/或比例时的签名。 GestureTapCallback（） →无效发生敲击时的签名。 GestureTapCancelCallback（） →无效当先前触发a的指针GestureTapDownCallback不会导致点击时的签名 。 GestureTapDownCallback（TapDownDetails 详细信息） →无效当可能导致点击的指针与屏幕接触时的签名。[…] GestureTapUpCallback（TapUpDetails 详细信息） →无效当触发敲击的指针停止接触屏幕时的签名。[…] ImageListener（ImageInfo image， bool synchronousCall） →void报告图像可用的回调签名。[…] IndexedWidgetBuilder（BuildContext context， int index） → Widget用于为给定索引创建窗口widget的函数的签名，例如，在列表中。[…] InspectorSelectButtonBuilder（BuildContext context， VoidCallback onPressed） → Widget使用的构建器回调的签名 WidgetInspector.selectButtonBuilder。 InspectorSelectionChangedCallback（） →无效用于选择的签名更改回调 WidgetInspectorService.selectionChangedCallback。 LayoutWidgetBuilder（BuildContext context， BoxConstraints constraints） → Widget LayoutBuilder构建器函数 的签名。 LocaleResolutionCallback（Locale locale， Iterable &lt; Locale &gt; supportedLocales） → Locale签名WidgetsApp.localeResolutionCallback。[…] NestedScrollViewHeaderSliv​​ersBuilder（BuildContext context， bool innerBoxIsScrolled） → List &lt; Widget &gt;NestedScrollView用于构建其标题的 签名。[…] NotificationListenerCallback &lt; T扩展通知 &gt; （T 通知） → boolNotification听众 签名。[…] OrientationWidgetBuilder（BuildContext context， Orientation orientation） → Widget签名用于构建给定的widget的函数Orientation。[…] PointerCancelEventListener（PointerCancelEvent 事件） →void用于收听PointerCancelEvent活动的签名。[…] PointerDownEventListener（PointerDownEvent 事件） →void用于收听PointerDownEvent活动的签名。[…] PointerMoveEventListener（PointerMoveEvent 事件） →void用于收听PointerMoveEvent活动的签名。[…] PointerUpEventListener（PointerUpEvent 事件） →void用于收听PointerUpEvent活动的签名。[…] RouteFactory（RouteSettings 设置） → 路由为给定的路线设置创建路线。[…] RoutePageBuilder（BuildContext context， Animation &lt; double &gt; animation， Animation &lt; double &gt; secondaryAnimation） → Widget用于PageRouteBuilder构建路径主要内容的函数的签名。[…] RoutePredicate（路线 路线） → 布尔Navigator.popUntil谓词参数的 签名。 RouteTransitionsBuilder（BuildContext context， Animation &lt; double &gt; animation， Animation &lt; double &gt; secondaryAnimation， Widget child） → Widget用于PageRouteBuilder构建路径转换的函数的签名。[…] ScrollNotificationPredicate（ScrollNotification 通知） → bool谓词ScrollNotification，用于自定义侦听来自其子项的通知的widget。 SelectionChangedCallback（TextSelection selection， SelectionChangedCause cause） →void用户更改选择（包括光标位置）时报告的回调签名。 SemanticsBuilderCallback（Size size） → List &lt; CustomPainterSemantics &gt;返回的函数的签名CustomPainter.semanticsBuilder。[…] ShaderCallback（Rect bounds） → Shader签名为创建Shader给定的函数Rect。[…] StatefulWidgetBuilder（BuildContext context， StateSetter setState） → Widget使用的构建器回调的签名StatefulBuilder。[…] StateSetter（VoidCallback fn） →无效State.setState功能 的签名。 TextSelectionOverlayChanged（TextEditingValue value， Rect caretRect） →void签名报告变更的筛选组件 TextEditingValue为的目的TextSelectionOverlay。该 caretRect参数给出插入符在的坐标空间中的位置RenderBox由给定的TextSelectionOverlay.renderObject。[…] TransitionBuilder（BuildContext context， Widget child） → Widget给child建立widget的构建器。[…] TweenConstructor &lt; T &gt; （T targetValue） → Tween &lt; T &gt;签名Tween工厂。[…] TweenVisitor &lt; T &gt; （Tween &lt; T &gt; 补间， T targetValue， TweenConstructor &lt; T &gt; 构造函数） → Tween &lt; T &gt;传递回调的签名AnimatedWidgetBaseState.forEachTween。 ValueChanged &lt; T &gt; （T 值） →无效报告基础值已更改的回调签名。[…] ValueGetter &lt; T &gt; （） →T用于按需报告值的回调签名。[…] ValueSetter &lt; T &gt; （T 值） →无效用于报告已设置值的回调的签名。[…] ViewportBuilder（BuildContext context， ViewportOffset position） → Widget用于Scrollable构建视口的签名，通过该视口显示可滚动内容。 VoidCallback（） →无效没有参数的回调签名并且不返回任何数据。 WidgetBuilder（BuildContext context） → Widget用于创建窗口widget的函数的签名，例如StatelessWidget.build 或State.build。[…] WillPopCallback（） → 未来&lt; bool &gt;签名回拨，验证可以调用Navigator.pop。[…] 异常/错误 FlutterError用于报告特定于Flutter的断言失败和合同违规的错误类。 TickerCanceled当股票代码被取消时，TickerFuture.orCancel未来Ticker对象 抛出异常。","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://oneal.tech/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://oneal.tech/tags/Flutter/"}]},{"title":"Java 设计模式","slug":"java设计模式","date":"2018-07-30T09:29:16.000Z","updated":"2019-08-13T09:32:01.067Z","comments":true,"path":"back-end/2018-07-30-java-design-pattern.html","link":"","permalink":"https://oneal.tech/back-end/2018-07-30-java-design-pattern.html","excerpt":"一直需要的Java的设计模式.","text":"一直需要的Java的设计模式. 作者：CyC2018原文链接: 设计模式 一、概述设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。 拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。 源码以及 UML 图 二、创建型1. 单例（Singleton）意图确保一个类只有一个实例，并提供该实例的全局访问点。 类图使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。 私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。 实现（一）懒汉式-线程不安全 以下实现中，私有静态变量 uniqueInstance 被延迟化实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。 这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 if (uniqueInstance == null) ，并且此时 uniqueInstance 为 null，那么多个线程会执行 uniqueInstance = new Singleton(); 语句，这将导致多次实例化 uniqueInstance。 public class Singleton &#123; private static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125; （二）懒汉式-线程安全 只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了对 uniqueInstance 进行多次实例化的问题。 但是这样有一个问题，就是当一个线程进入该方法之后，其它线程试图进入该方法都必须等待，因此性能上有一定的损耗。 public static synchronized Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance;&#125; （三）饿汉式-线程安全 线程不安全问题主要是由于 uniqueInstance 被实例化了多次，如果 uniqueInstance 采用直接实例化的话，就不会被实例化多次，也就不会产生线程不安全问题。但是直接实例化的方式也丢失了延迟实例化带来的节约资源的优势。 private static Singleton uniqueInstance = new Singleton(); （四）双重校验锁-线程安全 uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行。也就是说，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。 双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。 public class Singleton &#123; private volatile static Singleton uniqueInstance; private Singleton() &#123; &#125; public static Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; synchronized (Singleton.class) &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; &#125; &#125; return uniqueInstance; &#125;&#125; 考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程同时执行 if 语句，那么两个线程就会同时进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 uniqueInstance = new Singleton(); 这条语句，只是先后的问题，也就是说会进行两次实例化，从而产生了两个实例。因此必须使用双重校验锁，也就是需要使用两个 if 语句。 if (uniqueInstance == null) &#123; synchronized (Singleton.class) &#123; uniqueInstance = new Singleton(); &#125;&#125; uniqueInstance 采用 volatile 关键字修饰也是很有必要的。uniqueInstance = new Singleton(); 这段代码其实是分为三步执行。 分配内存空间 初始化对象 将 uniqueInstance 指向分配的内存地址 但是由于 JVM 具有指令重排的特性，有可能执行顺序变为了 1&gt;3&gt;2，这在单线程情况下自然是没有问题。但如果是多线程下，有可能获得是一个还没有被初始化的实例，以致于程序出错。 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。 （五）静态内部类实现 当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例。 这种方式不仅具有延迟初始化的好处，而且由虚拟机提供了对线程安全的支持。 public class Singleton &#123; private Singleton() &#123; &#125; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getUniqueInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; （五）枚举实现 这是单例模式的最佳实践，它实现简单，并且在面对复杂的序列化或者反射攻击的时候，能够防止实例化多次。 public enum Singleton &#123; uniqueInstance;&#125; 考虑以下单例模式的实现，该 Singleton 在每次序列化的时候都会创建一个新的实例，为了保证只创建一个实例，必须声明所有字段都是 transient，并且提供一个 readResolve() 方法。 public class Singleton implements Serializable &#123; private static Singleton uniqueInstance; private Singleton() &#123; &#125; public static synchronized Singleton getUniqueInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton(); &#125; return uniqueInstance; &#125;&#125; 如果不使用枚举来实现单例模式，会出现反射攻击，因为通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象。如果要防止这种攻击，需要在构造函数中添加防止实例化第二个对象的代码。 从上面的讨论可以看出，解决序列化和反射攻击很麻烦，而枚举实现不会出现这两种问题，所以说枚举实现单例模式是最佳实践。 使用场景 Logger Classes Configuration Classes Accesing resources in shared mode Factories implemented as Singletons JDK java.lang.Runtime#getRuntime() java.awt.Desktop#getDesktop() java.lang.System#getSecurityManager() 2. 简单工厂（Simple Factory）意图在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。 类图简单工厂不是设计模式，更像是一种编程习惯。它把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。 这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。因为客户类往往有多个，如果不使用简单工厂，所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。 如果存在下面这种代码，就需要使用简单工厂将对象实例化的部分放到简单工厂中。 public class Client &#123; public static void main(String[] args) &#123; int type = 1; Product product; if (type == 1) &#123; product = new ConcreteProduct1(); &#125; else if (type == 2) &#123; product = new ConcreteProduct2(); &#125; else &#123; product = new ConcreteProduct(); &#125; &#125;&#125; 实现public interface Product &#123;&#125; public class ConcreteProduct implements Product &#123;&#125; public class ConcreteProduct1 implements Product &#123;&#125; public class ConcreteProduct2 implements Product &#123;&#125; public class SimpleFactory &#123; public Product createProduct(int type) &#123; if (type == 1) &#123; return new ConcreteProduct1(); &#125; else if (type == 2) &#123; return new ConcreteProduct2(); &#125; return new ConcreteProduct(); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; SimpleFactory simpleFactory = new SimpleFactory(); Product product = simpleFactory.createProduct(1); &#125;&#125; 3. 工厂方法（Factory Method）意图定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化推迟到子类。 类图在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。 下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。 实现public abstract class Factory &#123; abstract public Product factoryMethod(); public void doSomething() &#123; Product product = factoryMethod(); // do something with the product &#125;&#125; public class ConcreteFactory extends Factory &#123; public Product factoryMethod() &#123; return new ConcreteProduct(); &#125;&#125; public class ConcreteFactory1 extends Factory &#123; public Product factoryMethod() &#123; return new ConcreteProduct1(); &#125;&#125; public class ConcreteFactory2 extends Factory &#123; public Product factoryMethod() &#123; return new ConcreteProduct2(); &#125;&#125; JDK java.util.Calendar java.util.ResourceBundle java.text.NumberFormat java.nio.charset.Charset java.net.URLStreamHandlerFactory java.util.EnumSet javax.xml.bind.JAXBContext 4. 抽象工厂（Abstract Factory）意图提供一个接口，用于创建 相关的对象家族 。 类图抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。 抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。 至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。 从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。 代码实现public class AbstractProductA &#123;&#125; public class AbstractProductB &#123;&#125; public class ProductA1 extends AbstractProductA &#123;&#125; public class ProductA2 extends AbstractProductA &#123;&#125; public class ProductB1 extends AbstractProductB &#123;&#125; public class ProductB2 extends AbstractProductB &#123;&#125; public abstract class AbstractFactory &#123; abstract AbstractProductA createProductA(); abstract AbstractProductB createProductB();&#125; public class ConcreteFactory1 extends AbstractFactory &#123; AbstractProductA createProductA() &#123; return new ProductA1(); &#125; AbstractProductB createProductB() &#123; return new ProductB1(); &#125;&#125; public class ConcreteFactory2 extends AbstractFactory &#123; AbstractProductA createProductA() &#123; return new ProductA2(); &#125; AbstractProductB createProductB() &#123; return new ProductB2(); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; AbstractFactory abstractFactory = new ConcreteFactory1(); AbstractProductA productA = abstractFactory.createProductA(); AbstractProductB productB = abstractFactory.createProductB(); // do something with productA and productB &#125;&#125; JDK javax.xml.parsers.DocumentBuilderFactory javax.xml.transform.TransformerFactory javax.xml.xpath.XPathFactory 5. 生成器（Builder）意图封装一个对象的构造过程，并允许按步骤构造。 类图 实现以下是一个简易的 StringBuilder 实现，参考了 JDK 1.8 源码。 public class AbstractStringBuilder &#123; protected char[] value; protected int count; public AbstractStringBuilder(int capacity) &#123; count = 0; value = new char[capacity]; &#125; public AbstractStringBuilder append(char c) &#123; ensureCapacityInternal(count + 1); value[count++] = c; return this; &#125; private void ensureCapacityInternal(int minimumCapacity) &#123; // overflow-conscious code if (minimumCapacity - value.length &gt; 0) expandCapacity(minimumCapacity); &#125; void expandCapacity(int minimumCapacity) &#123; int newCapacity = value.length * 2 + 2; if (newCapacity - minimumCapacity &lt; 0) newCapacity = minimumCapacity; if (newCapacity &lt; 0) &#123; if (minimumCapacity &lt; 0) // overflow throw new OutOfMemoryError(); newCapacity = Integer.MAX_VALUE; &#125; value = Arrays.copyOf(value, newCapacity); &#125;&#125; public class StringBuilder extends AbstractStringBuilder &#123; public StringBuilder() &#123; super(16); &#125; @Override public String toString() &#123; // Create a copy, don't share the array return new String(value, 0, count); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; StringBuilder sb = new StringBuilder(); final int count = 26; for (int i = 0; i &lt; count; i++) &#123; sb.append((char) ('a' + i)); &#125; System.out.println(sb.toString()); &#125;&#125; abcdefghijklmnopqrstuvwxyz JDK java.lang.StringBuilder java.nio.ByteBuffer java.lang.StringBuffer java.lang.Appendable Apache Camel builders 6. 原型模式（Prototype）意图使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。 类图 实现public abstract class Prototype &#123; abstract Prototype myClone();&#125; public class ConcretePrototype extends Prototype &#123; private String filed; public ConcretePrototype(String filed) &#123; this.filed = filed; &#125; @Override Prototype myClone() &#123; return new ConcretePrototype(filed); &#125; @Override public String toString() &#123; return filed; &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Prototype prototype = new ConcretePrototype(\"abc\"); Prototype clone = prototype.myClone(); System.out.println(clone.toString()); &#125;&#125; abc JDK java.lang.Object#clone() 三、行为型1. 责任链（Chain Of Responsibility）意图使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。 类图 Handler：定义处理请求的接口，并且实现后继链（successor） 实现public abstract class Handler &#123; protected Handler successor; public Handler(Handler successor) &#123; this.successor = successor; &#125; protected abstract void handleRequest(Request request);&#125; public class ConcreteHandler1 extends Handler &#123; public ConcreteHandler1(Handler successor) &#123; super(successor); &#125; @Override protected void handleRequest(Request request) &#123; if (request.getType() == RequestType.type1) &#123; System.out.println(request.getName() + \" is handle by ConcreteHandler1\"); return; &#125; if (successor != null) &#123; successor.handleRequest(request); &#125; &#125;&#125; public class ConcreteHandler2 extends Handler&#123; public ConcreteHandler2(Handler successor) &#123; super(successor); &#125; @Override protected void handleRequest(Request request) &#123; if (request.getType() == RequestType.type2) &#123; System.out.println(request.getName() + \" is handle by ConcreteHandler2\"); return; &#125; if (successor != null) &#123; successor.handleRequest(request); &#125; &#125;&#125; public class Request &#123; private RequestType type; private String name; public Request(RequestType type, String name) &#123; this.type = type; this.name = name; &#125; public RequestType getType() &#123; return type; &#125; public String getName() &#123; return name; &#125;&#125; public enum RequestType &#123; type1, type2&#125; public class Client &#123; public static void main(String[] args) &#123; Handler handler1 = new ConcreteHandler1(null); Handler handler2 = new ConcreteHandler2(handler1); Request request1 = new Request(RequestType.type1, \"request1\"); handler2.handleRequest(request1); Request request2 = new Request(RequestType.type2, \"request2\"); handler2.handleRequest(request2); &#125;&#125; request1 is handle by ConcreteHandler1request2 is handle by ConcreteHandler2 JDK java.util.logging.Logger#log() Apache Commons Chain javax.servlet.Filter#doFilter() 2. 命令（Command）意图将命令封装成对象中，以便使用命令来参数化其它对象，或者将命令对象放入队列中进行排队，或者将命令对象的操作记录到日志中，以及支持可撤销的操作。 类图 Command：命令 Receiver：命令接收者，也就是命令真正的执行者 Invoker：通过它来调用命令 Client：可以设置命令与命令的接收者 实现设计一个遥控器，可以控制电灯开关。 public interface Command &#123; void execute();&#125; public class LightOnCommand implements Command &#123; Light light; public LightOnCommand(Light light) &#123; this.light = light; &#125; @Override public void execute() &#123; light.on(); &#125;&#125; public class LightOffCommand implements Command &#123; Light light; public LightOffCommand(Light light) &#123; this.light = light; &#125; @Override public void execute() &#123; light.off(); &#125;&#125; public class Light &#123; public void on() &#123; System.out.println(\"Light is on!\"); &#125; public void off() &#123; System.out.println(\"Light is off!\"); &#125;&#125; /** * 遥控器 */public class Invoker &#123; private Command[] onCommands; private Command[] offCommands; private final int slotNum = 7; public Invoker() &#123; this.onCommands = new Command[slotNum]; this.offCommands = new Command[slotNum]; &#125; public void setOnCommand(Command command, int slot) &#123; onCommands[slot] = command; &#125; public void setOffCommand(Command command, int slot) &#123; offCommands[slot] = command; &#125; public void onButtonWasPushed(int slot) &#123; onCommands[slot].execute(); &#125; public void offButtonWasPushed(int slot) &#123; offCommands[slot].execute(); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Invoker invoker = new Invoker(); Light light = new Light(); Command lightOnCommand = new LightOnCommand(light); Command lightOffCommand = new LightOffCommand(light); invoker.setOnCommand(lightOnCommand, 0); invoker.setOffCommand(lightOffCommand, 0); invoker.onButtonWasPushed(0); invoker.offButtonWasPushed(0); &#125;&#125; JDK java.lang.Runnable Netflix Hystrix javax.swing.Action 3. 解释器（Interpreter）意图为语言创建解释器，通常由语言的语法和语法分析来定义。 类图 TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression Context：上下文，包含解释器之外的一些全局信息 实现以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。 例如一颗解析树为 D And (A Or (B C))，文本 “D A” 满足该解析树定义的规则。 这里的 Context 指的是 String。 public abstract class Expression &#123; public abstract boolean interpret(String str);&#125; public class TerminalExpression extends Expression &#123; private String literal = null; public TerminalExpression(String str) &#123; literal = str; &#125; public boolean interpret(String str) &#123; StringTokenizer st = new StringTokenizer(str); while (st.hasMoreTokens()) &#123; String test = st.nextToken(); if (test.equals(literal)) &#123; return true; &#125; &#125; return false; &#125;&#125; public class AndExpression extends Expression &#123; private Expression expression1 = null; private Expression expression2 = null; public AndExpression(Expression expression1, Expression expression2) &#123; this.expression1 = expression1; this.expression2 = expression2; &#125; public boolean interpret(String str) &#123; return expression1.interpret(str) &amp;&amp; expression2.interpret(str); &#125;&#125; public class OrExpression extends Expression &#123; private Expression expression1 = null; private Expression expression2 = null; public OrExpression(Expression expression1, Expression expression2) &#123; this.expression1 = expression1; this.expression2 = expression2; &#125; public boolean interpret(String str) &#123; return expression1.interpret(str) || expression2.interpret(str); &#125;&#125; public class Client &#123; /** * 构建解析树 */ public static Expression buildInterpreterTree() &#123; // Literal Expression terminal1 = new TerminalExpression(\"A\"); Expression terminal2 = new TerminalExpression(\"B\"); Expression terminal3 = new TerminalExpression(\"C\"); Expression terminal4 = new TerminalExpression(\"D\"); // B C Expression alternation1 = new OrExpression(terminal2, terminal3); // A Or (B C) Expression alternation2 = new OrExpression(terminal1, alternation1); // D And (A Or (B C)) return new AndExpression(terminal4, alternation2); &#125; public static void main(String[] args) &#123; Expression define = buildInterpreterTree(); String context1 = \"D A\"; String context2 = \"A B\"; System.out.println(define.interpret(context1)); System.out.println(define.interpret(context2)); &#125;&#125; truefalse JDK java.util.Pattern java.text.Normalizer All subclasses of java.text.Format javax.el.ELResolver 4. 迭代器（Iterator）意图提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。 类图 Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator； Iterator 主要定义了 hasNext() 和 next() 方法。 Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。 实现public interface Aggregate &#123; Iterator createIterator();&#125; public class ConcreteAggregate implements Aggregate &#123; private Integer[] items; public ConcreteAggregate() &#123; items = new Integer[10]; for (int i = 0; i &lt; items.length; i++) &#123; items[i] = i; &#125; &#125; @Override public Iterator createIterator() &#123; return new ConcreteIterator&lt;Integer&gt;(items); &#125;&#125; public interface Iterator&lt;Item&gt; &#123; Item next(); boolean hasNext();&#125; public class ConcreteIterator&lt;Item&gt; implements Iterator &#123; private Item[] items; private int position = 0; public ConcreteIterator(Item[] items) &#123; this.items = items; &#125; @Override public Object next() &#123; return items[position++]; &#125; @Override public boolean hasNext() &#123; return position &lt; items.length; &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Aggregate aggregate = new ConcreteAggregate(); Iterator&lt;Integer&gt; iterator = aggregate.createIterator(); while (iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;&#125; JDK java.util.Iterator java.util.Enumeration 5. 中介者（Mediator）意图集中相关对象之间复杂的沟通和控制方式。 类图 Mediator：中介者，定义一个接口用于与各同事（Colleague）对象通信。 Colleague：同事，相关对象 实现Alarm（闹钟）、CoffeePot（咖啡壶）、Calendar（日历）、Sprinkler（喷头）是一组相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构： 使用中介者模式可以将复杂的依赖结构变成星形结构： public abstract class Colleague &#123; public abstract void onEvent(Mediator mediator);&#125; public class Alarm extends Colleague &#123; @Override public void onEvent(Mediator mediator) &#123; mediator.doEvent(\"alarm\"); &#125; public void doAlarm() &#123; System.out.println(\"doAlarm()\"); &#125;&#125; public class CoffeePot extends Colleague &#123; @Override public void onEvent(Mediator mediator) &#123; mediator.doEvent(\"coffeePot\"); &#125; public void doCoffeePot() &#123; System.out.println(\"doCoffeePot()\"); &#125;&#125; public class Calender extends Colleague &#123; @Override public void onEvent(Mediator mediator) &#123; mediator.doEvent(\"calender\"); &#125; public void doCalender() &#123; System.out.println(\"doCalender()\"); &#125;&#125; public class Sprinkler extends Colleague &#123; @Override public void onEvent(Mediator mediator) &#123; mediator.doEvent(\"sprinkler\"); &#125; public void doSprinkler() &#123; System.out.println(\"doSprinkler()\"); &#125;&#125; public abstract class Mediator &#123; public abstract void doEvent(String eventType);&#125; public class ConcreteMediator extends Mediator &#123; private Alarm alarm; private CoffeePot coffeePot; private Calender calender; private Sprinkler sprinkler; public ConcreteMediator(Alarm alarm, CoffeePot coffeePot, Calender calender, Sprinkler sprinkler) &#123; this.alarm = alarm; this.coffeePot = coffeePot; this.calender = calender; this.sprinkler = sprinkler; &#125; @Override public void doEvent(String eventType) &#123; switch (eventType) &#123; case \"alarm\": doAlarmEvent(); break; case \"coffeePot\": doCoffeePotEvent(); break; case \"calender\": doCalenderEvent(); break; default: doSprinklerEvent(); &#125; &#125; public void doAlarmEvent() &#123; alarm.doAlarm(); coffeePot.doCoffeePot(); calender.doCalender(); sprinkler.doSprinkler(); &#125; public void doCoffeePotEvent() &#123; // ... &#125; public void doCalenderEvent() &#123; // ... &#125; public void doSprinklerEvent() &#123; // ... &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Alarm alarm = new Alarm(); CoffeePot coffeePot = new CoffeePot(); Calender calender = new Calender(); Sprinkler sprinkler = new Sprinkler(); Mediator mediator = new ConcreteMediator(alarm, coffeePot, calender, sprinkler); // 闹钟事件到达，调用中介者就可以操作相关对象 alarm.onEvent(mediator); &#125;&#125; doAlarm()doCoffeePot()doCalender()doSprinkler() JDK All scheduleXXX() methods of java.util.Timer java.util.concurrent.Executor#execute() submit() and invokeXXX() methods of java.util.concurrent.ExecutorService scheduleXXX() methods of java.util.concurrent.ScheduledExecutorService java.lang.reflect.Method#invoke() 6. 备忘录（Memento）意图在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。 类图 Originator：原始对象 Caretaker：负责保存好备忘录 Menento：备忘录，存储原始对象的的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。 实现以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。 实现参考：Memento Pattern - Calculator Example - Java Sourcecode /** * Originator Interface */public interface Calculator &#123; // Create Memento PreviousCalculationToCareTaker backupLastCalculation(); // setMemento void restorePreviousCalculation(PreviousCalculationToCareTaker memento); int getCalculationResult(); void setFirstNumber(int firstNumber); void setSecondNumber(int secondNumber);&#125; /** * Originator Implementation */public class CalculatorImp implements Calculator &#123; private int firstNumber; private int secondNumber; @Override public PreviousCalculationToCareTaker backupLastCalculation() &#123; // create a memento object used for restoring two numbers return new PreviousCalculationImp(firstNumber, secondNumber); &#125; @Override public void restorePreviousCalculation(PreviousCalculationToCareTaker memento) &#123; this.firstNumber = ((PreviousCalculationToOriginator) memento).getFirstNumber(); this.secondNumber = ((PreviousCalculationToOriginator) memento).getSecondNumber(); &#125; @Override public int getCalculationResult() &#123; // result is adding two numbers return firstNumber + secondNumber; &#125; @Override public void setFirstNumber(int firstNumber) &#123; this.firstNumber = firstNumber; &#125; @Override public void setSecondNumber(int secondNumber) &#123; this.secondNumber = secondNumber; &#125;&#125; /** * Memento Interface to Originator * * This interface allows the originator to restore its state */public interface PreviousCalculationToOriginator &#123; int getFirstNumber(); int getSecondNumber();&#125; /** * Memento interface to CalculatorOperator (Caretaker) */public interface PreviousCalculationToCareTaker &#123; // no operations permitted for the caretaker&#125; /** * Memento Object Implementation * &lt;p&gt; * Note that this object implements both interfaces to Originator and CareTaker */public class PreviousCalculationImp implements PreviousCalculationToCareTaker, PreviousCalculationToOriginator &#123; private int firstNumber; private int secondNumber; public PreviousCalculationImp(int firstNumber, int secondNumber) &#123; this.firstNumber = firstNumber; this.secondNumber = secondNumber; &#125; @Override public int getFirstNumber() &#123; return firstNumber; &#125; @Override public int getSecondNumber() &#123; return secondNumber; &#125;&#125; /** * CareTaker object */public class Client &#123; public static void main(String[] args) &#123; // program starts Calculator calculator = new CalculatorImp(); // assume user enters two numbers calculator.setFirstNumber(10); calculator.setSecondNumber(100); // find result System.out.println(calculator.getCalculationResult()); // Store result of this calculation in case of error PreviousCalculationToCareTaker memento = calculator.backupLastCalculation(); // user enters a number calculator.setFirstNumber(17); // user enters a wrong second number and calculates result calculator.setSecondNumber(-290); // calculate result System.out.println(calculator.getCalculationResult()); // user hits CTRL + Z to undo last operation and see last result calculator.restorePreviousCalculation(memento); // result restored System.out.println(calculator.getCalculationResult()); &#125;&#125; 110-273110 JDK java.io.Serializable 7. 观察者（Observer）意图定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。 主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。 类图主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。 观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。 实现天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。 public interface Subject &#123; void resisterObserver(Observer o); void removeObserver(Observer o); void notifyObserver();&#125; public class WeatherData implements Subject &#123; private List&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; observers = new ArrayList&lt;&gt;(); &#125; public void setMeasurements(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; notifyObserver(); &#125; @Override public void resisterObserver(Observer o) &#123; observers.add(o); &#125; @Override public void removeObserver(Observer o) &#123; int i = observers.indexOf(o); if (i &gt;= 0) &#123; observers.remove(i); &#125; &#125; @Override public void notifyObserver() &#123; for (Observer o : observers) &#123; o.update(temperature, humidity, pressure); &#125; &#125;&#125; public interface Observer &#123; void update(float temp, float humidity, float pressure);&#125; public class StatisticsDisplay implements Observer &#123; public StatisticsDisplay(Subject weatherData) &#123; weatherData.resisterObserver(this); &#125; @Override public void update(float temp, float humidity, float pressure) &#123; System.out.println(\"StatisticsDisplay.update: \" + temp + \" \" + humidity + \" \" + pressure); &#125;&#125; public class CurrentConditionsDisplay implements Observer &#123; public CurrentConditionsDisplay(Subject weatherData) &#123; weatherData.resisterObserver(this); &#125; @Override public void update(float temp, float humidity, float pressure) &#123; System.out.println(\"CurrentConditionsDisplay.update: \" + temp + \" \" + humidity + \" \" + pressure); &#125;&#125; public class WeatherStation &#123; public static void main(String[] args) &#123; WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData); StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData); weatherData.setMeasurements(0, 0, 0); weatherData.setMeasurements(1, 1, 1); &#125;&#125; CurrentConditionsDisplay.update: 0.0 0.0 0.0StatisticsDisplay.update: 0.0 0.0 0.0CurrentConditionsDisplay.update: 1.0 1.0 1.0StatisticsDisplay.update: 1.0 1.0 1.0 JDK java.util.Observer java.util.EventListener javax.servlet.http.HttpSessionBindingListener RxJava 8. 状态（State）意图允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。 类图 实现糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。 public interface State &#123; /** * 投入 25 分钱 */ void insertQuarter(); /** * 退回 25 分钱 */ void ejectQuarter(); /** * 转动曲柄 */ void turnCrank(); /** * 发放糖果 */ void dispense();&#125; public class HasQuarterState implements State &#123; private GumballMachine gumballMachine; public HasQuarterState(GumballMachine gumballMachine) &#123; this.gumballMachine = gumballMachine; &#125; @Override public void insertQuarter() &#123; System.out.println(\"You can't insert another quarter\"); &#125; @Override public void ejectQuarter() &#123; System.out.println(\"Quarter returned\"); gumballMachine.setState(gumballMachine.getNoQuarterState()); &#125; @Override public void turnCrank() &#123; System.out.println(\"You turned...\"); gumballMachine.setState(gumballMachine.getSoldState()); &#125; @Override public void dispense() &#123; System.out.println(\"No gumball dispensed\"); &#125;&#125; public class NoQuarterState implements State &#123; GumballMachine gumballMachine; public NoQuarterState(GumballMachine gumballMachine) &#123; this.gumballMachine = gumballMachine; &#125; @Override public void insertQuarter() &#123; System.out.println(\"You insert a quarter\"); gumballMachine.setState(gumballMachine.getHasQuarterState()); &#125; @Override public void ejectQuarter() &#123; System.out.println(\"You haven't insert a quarter\"); &#125; @Override public void turnCrank() &#123; System.out.println(\"You turned, but there's no quarter\"); &#125; @Override public void dispense() &#123; System.out.println(\"You need to pay first\"); &#125;&#125; public class SoldOutState implements State &#123; GumballMachine gumballMachine; public SoldOutState(GumballMachine gumballMachine) &#123; this.gumballMachine = gumballMachine; &#125; @Override public void insertQuarter() &#123; System.out.println(\"You can't insert a quarter, the machine is sold out\"); &#125; @Override public void ejectQuarter() &#123; System.out.println(\"You can't eject, you haven't inserted a quarter yet\"); &#125; @Override public void turnCrank() &#123; System.out.println(\"You turned, but there are no gumballs\"); &#125; @Override public void dispense() &#123; System.out.println(\"No gumball dispensed\"); &#125;&#125; public class SoldState implements State &#123; GumballMachine gumballMachine; public SoldState(GumballMachine gumballMachine) &#123; this.gumballMachine = gumballMachine; &#125; @Override public void insertQuarter() &#123; System.out.println(\"Please wait, we're already giving you a gumball\"); &#125; @Override public void ejectQuarter() &#123; System.out.println(\"Sorry, you already turned the crank\"); &#125; @Override public void turnCrank() &#123; System.out.println(\"Turning twice doesn't get you another gumball!\"); &#125; @Override public void dispense() &#123; gumballMachine.releaseBall(); if (gumballMachine.getCount() &gt; 0) &#123; gumballMachine.setState(gumballMachine.getNoQuarterState()); &#125; else &#123; System.out.println(\"Oops, out of gumballs\"); gumballMachine.setState(gumballMachine.getSoldOutState()); &#125; &#125;&#125; public class GumballMachine &#123; private State soldOutState; private State noQuarterState; private State hasQuarterState; private State soldState; private State state; private int count = 0; public GumballMachine(int numberGumballs) &#123; count = numberGumballs; soldOutState = new SoldOutState(this); noQuarterState = new NoQuarterState(this); hasQuarterState = new HasQuarterState(this); soldState = new SoldState(this); if (numberGumballs &gt; 0) &#123; state = noQuarterState; &#125; else &#123; state = soldOutState; &#125; &#125; public void insertQuarter() &#123; state.insertQuarter(); &#125; public void ejectQuarter() &#123; state.ejectQuarter(); &#125; public void turnCrank() &#123; state.turnCrank(); state.dispense(); &#125; public void setState(State state) &#123; this.state = state; &#125; public void releaseBall() &#123; System.out.println(\"A gumball comes rolling out the slot...\"); if (count != 0) &#123; count -= 1; &#125; &#125; public State getSoldOutState() &#123; return soldOutState; &#125; public State getNoQuarterState() &#123; return noQuarterState; &#125; public State getHasQuarterState() &#123; return hasQuarterState; &#125; public State getSoldState() &#123; return soldState; &#125; public int getCount() &#123; return count; &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; GumballMachine gumballMachine = new GumballMachine(5); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.ejectQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.ejectQuarter(); gumballMachine.insertQuarter(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); gumballMachine.insertQuarter(); gumballMachine.turnCrank(); &#125;&#125; You insert a quarterYou turned...A gumball comes rolling out the slot...You insert a quarterQuarter returnedYou turned, but there's no quarterYou need to pay firstYou insert a quarterYou turned...A gumball comes rolling out the slot...You insert a quarterYou turned...A gumball comes rolling out the slot...You haven't insert a quarterYou insert a quarterYou can't insert another quarterYou turned...A gumball comes rolling out the slot...You insert a quarterYou turned...A gumball comes rolling out the slot...Oops, out of gumballsYou can't insert a quarter, the machine is sold outYou turned, but there are no gumballsNo gumball dispensed 9. 策略（Strategy）意图定义一系列算法，封装每个算法，并使它们可以互换。 策略模式可以让算法独立于使用它的客户端。 类图 Strategy 接口定义了一个算法族，它们都具有 behavior() 方法。 Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(in Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。 与状态模式的比较状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。 但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。 所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。 状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。 实现设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。 public interface QuackBehavior &#123; void quack();&#125; public class Quack implements QuackBehavior &#123; @Override public void quack() &#123; System.out.println(\"quack!\"); &#125;&#125; public class Squeak implements QuackBehavior&#123; @Override public void quack() &#123; System.out.println(\"squeak!\"); &#125;&#125; public class Duck &#123; private QuackBehavior quackBehavior; public void performQuack() &#123; if (quackBehavior != null) &#123; quackBehavior.quack(); &#125; &#125; public void setQuackBehavior(QuackBehavior quackBehavior) &#123; this.quackBehavior = quackBehavior; &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Duck duck = new Duck(); duck.setQuackBehavior(new Squeak()); duck.performQuack(); duck.setQuackBehavior(new Quack()); duck.performQuack(); &#125;&#125; squeak!quack! JDK java.util.Comparator#compare() javax.servlet.http.HttpServlet javax.servlet.Filter#doFilter() 10. 模板方法（Template Method）意图定义算法框架，并将一些步骤的实现延迟到子类。 通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。 类图 实现冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。 public abstract class CaffeineBeverage &#123; final void prepareRecipe() &#123; boilWater(); brew(); pourInCup(); addCondiments(); &#125; abstract void brew(); abstract void addCondiments(); void boilWater() &#123; System.out.println(\"boilWater\"); &#125; void pourInCup() &#123; System.out.println(\"pourInCup\"); &#125;&#125; public class Coffee extends CaffeineBeverage&#123; @Override void brew() &#123; System.out.println(\"Coffee.brew\"); &#125; @Override void addCondiments() &#123; System.out.println(\"Coffee.addCondiments\"); &#125;&#125; public class Tea extends CaffeineBeverage&#123; @Override void brew() &#123; System.out.println(\"Tea.brew\"); &#125; @Override void addCondiments() &#123; System.out.println(\"Tea.addCondiments\"); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; CaffeineBeverage caffeineBeverage = new Coffee(); caffeineBeverage.prepareRecipe(); System.out.println(\"-----------\"); caffeineBeverage = new Tea(); caffeineBeverage.prepareRecipe(); &#125;&#125; boilWaterCoffee.brewpourInCupCoffee.addCondiments-----------boilWaterTea.brewpourInCupTea.addCondiments JDK java.util.Collections#sort() java.io.InputStream#skip() java.io.InputStream#read() java.util.AbstractList#indexOf() 11. 访问者（Visitor）意图为一个对象结构（比如组合结构）增加新能力。 类图 Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作 ConcreteVisitor：具体访问者，存储遍历过程中的累计结果 ObjectStructure：对象结构，可以是组合结构，或者是一个集合。 实现public interface Element &#123; void accept(Visitor visitor);&#125; class CustomerGroup &#123; private List&lt;Customer&gt; customers = new ArrayList&lt;&gt;(); void accept(Visitor visitor) &#123; for (Customer customer : customers) &#123; customer.accept(visitor); &#125; &#125; void addCustomer(Customer customer) &#123; customers.add(customer); &#125;&#125; public class Customer implements Element &#123; private String name; private List&lt;Order&gt; orders = new ArrayList&lt;&gt;(); Customer(String name) &#123; this.name = name; &#125; String getName() &#123; return name; &#125; void addOrder(Order order) &#123; orders.add(order); &#125; public void accept(Visitor visitor) &#123; visitor.visit(this); for (Order order : orders) &#123; order.accept(visitor); &#125; &#125;&#125; public class Order implements Element &#123; private String name; private List&lt;Item&gt; items = new ArrayList(); Order(String name) &#123; this.name = name; &#125; Order(String name, String itemName) &#123; this.name = name; this.addItem(new Item(itemName)); &#125; String getName() &#123; return name; &#125; void addItem(Item item) &#123; items.add(item); &#125; public void accept(Visitor visitor) &#123; visitor.visit(this); for (Item item : items) &#123; item.accept(visitor); &#125; &#125;&#125; public class Item implements Element &#123; private String name; Item(String name) &#123; this.name = name; &#125; String getName() &#123; return name; &#125; public void accept(Visitor visitor) &#123; visitor.visit(this); &#125;&#125; public interface Visitor &#123; void visit(Customer customer); void visit(Order order); void visit(Item item);&#125; public class GeneralReport implements Visitor &#123; private int customersNo; private int ordersNo; private int itemsNo; public void visit(Customer customer) &#123; System.out.println(customer.getName()); customersNo++; &#125; public void visit(Order order) &#123; System.out.println(order.getName()); ordersNo++; &#125; public void visit(Item item) &#123; System.out.println(item.getName()); itemsNo++; &#125; public void displayResults() &#123; System.out.println(\"Number of customers: \" + customersNo); System.out.println(\"Number of orders: \" + ordersNo); System.out.println(\"Number of items: \" + itemsNo); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Customer customer1 = new Customer(\"customer1\"); customer1.addOrder(new Order(\"order1\", \"item1\")); customer1.addOrder(new Order(\"order2\", \"item1\")); customer1.addOrder(new Order(\"order3\", \"item1\")); Order order = new Order(\"order_a\"); order.addItem(new Item(\"item_a1\")); order.addItem(new Item(\"item_a2\")); order.addItem(new Item(\"item_a3\")); Customer customer2 = new Customer(\"customer2\"); customer2.addOrder(order); CustomerGroup customers = new CustomerGroup(); customers.addCustomer(customer1); customers.addCustomer(customer2); GeneralReport visitor = new GeneralReport(); customers.accept(visitor); visitor.displayResults(); &#125;&#125; customer1order1item1order2item1order3item1customer2order_aitem_a1item_a2item_a3Number of customers: 2Number of orders: 4Number of items: 6 JDK javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor 12. 空对象（Null）意图使用什么都不做的空对象来替代 NULL。 一个方法返回 NULL，意味着方法的调用端需要去检查返回值是否是 NULL，这么做会导致非常多的冗余的检查代码。并且如果某一个调用端忘记了做这个检查返回值，而直接使用返回的对象，那么就有可能抛出空指针异常。 类图 实现public abstract class AbstractOperation &#123; abstract void request();&#125; public class RealOperation extends AbstractOperation &#123; @Override void request() &#123; System.out.println(\"do something\"); &#125;&#125; public class NullOperation extends AbstractOperation&#123; @Override void request() &#123; // do nothing &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; AbstractOperation abstractOperation = func(-1); abstractOperation.request(); &#125; public static AbstractOperation func(int para) &#123; if (para &lt; 0) &#123; return new NullOperation(); &#125; return new RealOperation(); &#125;&#125; 四、结构型1. 适配器（Adapter）意图把一个类接口转换成另一个用户需要的接口。 类图 实现鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。 要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！ public interface Duck &#123; void quack();&#125; public interface Turkey &#123; void gobble();&#125; public class WildTurkey implements Turkey &#123; @Override public void gobble() &#123; System.out.println(\"gobble!\"); &#125;&#125; public class TurkeyAdapter implements Duck &#123; Turkey turkey; public TurkeyAdapter(Turkey turkey) &#123; this.turkey = turkey; &#125; @Override public void quack() &#123; turkey.gobble(); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Turkey turkey = new WildTurkey(); Duck duck = new TurkeyAdapter(turkey); duck.quack(); &#125;&#125; JDK java.util.Arrays#asList() java.util.Collections#list() java.util.Collections#enumeration() javax.xml.bind.annotation.adapters.XMLAdapter 2. 桥接（Bridge）意图将抽象与实现分离开来，使它们可以独立变化。 类图 Abstraction：定义抽象类的接口 Implementor：定义实现类接口 实现RemoteControl 表示遥控器，指代 Abstraction。 TV 表示电视，指代 Implementor。 桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。 public abstract class TV &#123; public abstract void on(); public abstract void off(); public abstract void tuneChannel();&#125; public class Sony extends TV&#123; @Override public void on() &#123; System.out.println(\"Sony.on()\"); &#125; @Override public void off() &#123; System.out.println(\"Sony.off()\"); &#125; @Override public void tuneChannel() &#123; System.out.println(\"Sony.tuneChannel()\"); &#125;&#125; public class RCA extends TV&#123; @Override public void on() &#123; System.out.println(\"RCA.on()\"); &#125; @Override public void off() &#123; System.out.println(\"RCA.off()\"); &#125; @Override public void tuneChannel() &#123; System.out.println(\"RCA.tuneChannel()\"); &#125;&#125; public abstract class RemoteControl &#123; protected TV tv; public RemoteControl(TV tv) &#123; this.tv = tv; &#125; public abstract void on(); public abstract void off(); public abstract void tuneChannel();&#125; public class ConcreteRemoteControl1 extends RemoteControl &#123; public ConcreteRemoteControl1(TV tv) &#123; super(tv); &#125; @Override public void on() &#123; System.out.println(\"ConcreteRemoteControl1.on()\"); tv.on(); &#125; @Override public void off() &#123; System.out.println(\"ConcreteRemoteControl1.off()\"); tv.off(); &#125; @Override public void tuneChannel() &#123; System.out.println(\"ConcreteRemoteControl1.tuneChannel()\"); tv.tuneChannel(); &#125;&#125; public class ConcreteRemoteControl2 extends RemoteControl &#123; public ConcreteRemoteControl2(TV tv) &#123; super(tv); &#125; @Override public void on() &#123; System.out.println(\"ConcreteRemoteControl2.on()\"); tv.on(); &#125; @Override public void off() &#123; System.out.println(\"ConcreteRemoteControl2.off()\"); tv.off(); &#125; @Override public void tuneChannel() &#123; System.out.println(\"ConcreteRemoteControl2.tuneChannel()\"); tv.tuneChannel(); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; RemoteControl remoteControl1 = new ConcreteRemoteControl1(new RCA()); remoteControl1.on(); remoteControl1.off(); remoteControl1.tuneChannel(); &#125;&#125; JDK AWT (It provides an abstraction layer which maps onto the native OS the windowing support.) JDBC 3. 组合（Composite）意图将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。 类图组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。 组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。 实现public abstract class Component &#123; protected String name; public Component(String name) &#123; this.name = name; &#125; public void print() &#123; print(0); &#125; abstract void print(int level); abstract public void add(Component component); abstract public void remove(Component component);&#125; import java.util.ArrayList;import java.util.List;public class Composite extends Component &#123; private List&lt;Component&gt; child; public Composite(String name) &#123; super(name); child = new ArrayList&lt;&gt;(); &#125; @Override void print(int level) &#123; for (int i = 0; i &lt; level; i++) &#123; System.out.print(\"--\"); &#125; System.out.println(\"Composite:\" + name); for (Component component : child) &#123; component.print(level + 1); &#125; &#125; @Override public void add(Component component) &#123; child.add(component); &#125; @Override public void remove(Component component) &#123; child.remove(component); &#125;&#125; public class Leaf extends Component &#123; public Leaf(String name) &#123; super(name); &#125; @Override void print(int level) &#123; for (int i = 0; i &lt; level; i++) &#123; System.out.print(\"--\"); &#125; System.out.println(\"left:\" + name); &#125; @Override public void add(Component component) &#123; throw new UnsupportedOperationException(); // 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点 &#125; @Override public void remove(Component component) &#123; throw new UnsupportedOperationException(); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Composite root = new Composite(\"root\"); Component node1 = new Leaf(\"1\"); Component node2 = new Composite(\"2\"); Component node3 = new Leaf(\"3\"); root.add(node1); root.add(node2); root.add(node3); Component node21 = new Leaf(\"21\"); Component node22 = new Composite(\"22\"); node2.add(node21); node2.add(node22); Component node221 = new Leaf(\"221\"); node22.add(node221); root.print(); &#125;&#125; Composite:root--left:1--Composite:2----left:21----Composite:22------left:221--left:3 JDK javax.swing.JComponent#add(Component) java.awt.Container#add(Component) java.util.Map#putAll(Map) java.util.List#addAll(Collection) java.util.Set#addAll(Collection) 4. 装饰（Decorator）意图为对象动态添加功能。 类图装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。 实现设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。 下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。 public interface Beverage &#123; double cost();&#125; public class DarkRoast implements Beverage &#123; @Override public double cost() &#123; return 1; &#125;&#125; public class HouseBlend implements Beverage &#123; @Override public double cost() &#123; return 1; &#125;&#125; public abstract class CondimentDecorator implements Beverage &#123; protected Beverage beverage;&#125; public class Milk extends CondimentDecorator &#123; public Milk(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public double cost() &#123; return 1 + beverage.cost(); &#125;&#125; public class Mocha extends CondimentDecorator &#123; public Mocha(Beverage beverage) &#123; this.beverage = beverage; &#125; @Override public double cost() &#123; return 1 + beverage.cost(); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Beverage beverage = new HouseBlend(); beverage = new Mocha(beverage); beverage = new Milk(beverage); System.out.println(beverage.cost()); &#125;&#125; 3.0 设计原则类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。 不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。 JDK java.io.BufferedInputStream(InputStream) java.io.DataInputStream(InputStream) java.io.BufferedOutputStream(OutputStream) java.util.zip.ZipOutputStream(OutputStream) java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap 5. 外观（Facade）意图提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。 类图 实现观看电影需要操作很多电器，使用外观模式可以实现一键看电影功能。 public class SubSystem &#123; public void turnOnTV() &#123; System.out.println(\"turnOnTV()\"); &#125; public void setCD(String cd) &#123; System.out.println(\"setCD( \" + cd + \" )\"); &#125; public void starWatching()&#123; System.out.println(\"starWatching()\"); &#125;&#125; public class Facade &#123; private SubSystem subSystem = new SubSystem(); public void watchMovie() &#123; subSystem.turnOnTV(); subSystem.setCD(\"a movie\"); subSystem.starWatching(); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; Facade facade = new Facade(); facade.watchMovie(); &#125;&#125; 设计原则最少知识原则：只和你的密友谈话。也就是客户对象所需要交互的对象应当尽可能少。 6. 享元（Flyweight）意图利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。 类图 Flyweight：享元对象 IntrinsicState：内部状态，相同的项元对象共享 ExtrinsicState：外部状态 实现public interface Flyweight &#123; void doOperation(String extrinsicState);&#125; public class ConcreteFlyweight implements Flyweight &#123; private String intrinsicState; public ConcreteFlyweight(String intrinsicState) &#123; this.intrinsicState = intrinsicState; &#125; @Override public void doOperation(String extrinsicState) &#123; System.out.println(\"Object address: \" + System.identityHashCode(this)); System.out.println(\"IntrinsicState: \" + intrinsicState); System.out.println(\"ExtrinsicState: \" + extrinsicState); &#125;&#125; import java.util.HashMap;public class FlyweightFactory &#123; private HashMap&lt;String, Flyweight&gt; flyweights = new HashMap&lt;&gt;(); Flyweight getFlyweight(String intrinsicState) &#123; if (!flyweights.containsKey(intrinsicState)) &#123; Flyweight flyweight = new ConcreteFlyweight(intrinsicState); flyweights.put(intrinsicState, flyweight); &#125; return flyweights.get(intrinsicState); &#125;&#125; public class Client &#123; public static void main(String[] args) &#123; FlyweightFactory factory = new FlyweightFactory(); Flyweight flyweight1 = factory.getFlyweight(\"aa\"); Flyweight flyweight2 = factory.getFlyweight(\"aa\"); flyweight1.doOperation(\"x\"); flyweight2.doOperation(\"y\"); &#125;&#125; Object address: 1163157884IntrinsicState: aaExtrinsicState: xObject address: 1163157884IntrinsicState: aaExtrinsicState: y JDKJava 利用缓存来加速大量小对象的访问时间。 java.lang.Integer#valueOf(int) java.lang.Boolean#valueOf(boolean) java.lang.Byte#valueOf(byte) java.lang.Character#valueOf(char) 7. 代理（Proxy）意图控制对其它对象的访问。 类图代理有以下四类： 远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。 虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。 保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。 智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数，比如智能智能；当第一次引用一个持久化对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。 实现以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。 public interface Image &#123; void showImage();&#125; public class HighResolutionImage implements Image &#123; private URL imageURL; private long startTime; private int height; private int width; public int getHeight() &#123; return height; &#125; public int getWidth() &#123; return width; &#125; public HighResolutionImage(URL imageURL) &#123; this.imageURL = imageURL; this.startTime = System.currentTimeMillis(); this.width = 600; this.height = 600; &#125; public boolean isLoad() &#123; // 模拟图片加载，延迟 3s 加载完成 long endTime = System.currentTimeMillis(); return endTime - startTime &gt; 3000; &#125; @Override public void showImage() &#123; System.out.println(\"Real Image: \" + imageURL); &#125;&#125; public class ImageProxy implements Image &#123; private HighResolutionImage highResolutionImage; public ImageProxy(HighResolutionImage highResolutionImage) &#123; this.highResolutionImage = highResolutionImage; &#125; @Override public void showImage() &#123; while (!highResolutionImage.isLoad()) &#123; try &#123; System.out.println(\"Temp Image: \" + highResolutionImage.getWidth() + \" \" + highResolutionImage.getHeight()); Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; highResolutionImage.showImage(); &#125;&#125; public class ImageViewer &#123; public static void main(String[] args) throws Exception &#123; String image = \"http://image.jpg\"; URL url = new URL(image); HighResolutionImage highResolutionImage = new HighResolutionImage(url); ImageProxy imageProxy = new ImageProxy(highResolutionImage); imageProxy.showImage(); &#125;&#125; JDK java.lang.reflect.Proxy RMI 参考资料 弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007. Gamma E. 设计模式: 可复用面向对象软件的基础 [M]. 机械工业出版社, 2007. Bloch J. Effective java[M]. Addison-Wesley Professional, 2017. Design Patterns Design patterns implemented in Java The breakdown of design patterns in JDK","categories":[{"name":"后端","slug":"back-end","permalink":"https://oneal.tech/categories/back-end/"}],"tags":[{"name":"Java设计模式","slug":"Java设计模式","permalink":"https://oneal.tech/tags/Java设计模式/"}]}]}