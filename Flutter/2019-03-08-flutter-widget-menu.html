<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="baidu-site-verification" content="0bXNmWKtT7">
  <meta name="google-site-verification" content="0tZ6cb1Ocb_Ad6l4LBmaudj_SWXf2rmmNvERmr_hNBY">
  <meta name="description" content="生活不止眼前的苟且,还有诗和远方的田野.">
  
    <meta name="keywords" content="Flutter,">
  

  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Flutter Widget 目录 | ONEAL.TECH
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="//zz.bdstatic.com/linksubmit/push.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png">
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>ONEAL.TECH</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>Flutter Widget 目录</h2>
  <p class="post-date">2019-03-08</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h2 id="widget库"><a href="#widget库" class="headerlink" title="widget库"></a>widget库</h2><h3 id="扑组件框架"><a href="#扑组件框架" class="headerlink" title="扑组件框架"></a>扑组件框架</h3><p>使用方法：进口 package:flutter/widgets.dart</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="AbsorbPointer"><a href="#AbsorbPointer" class="headerlink" title="AbsorbPointer"></a>AbsorbPointer</h4><p>在命中测试期间吸收指针的widget。[…]</p>
<h4 id="align"><a href="#align" class="headerlink" title="align"></a>align</h4><p>一个widget，用于将其子项与其自身对齐，并根据子级的大小自行调整大小。[…]</p>
<h4 id="对准"><a href="#对准" class="headerlink" title="对准"></a>对准</h4><p>矩形内的一个点。[…]</p>
<h4 id="AlignmentDirectional"><a href="#AlignmentDirectional" class="headerlink" title="AlignmentDirectional"></a>AlignmentDirectional</h4><p>偏移量，表示为“ 大小”的一部分，但其水平分量取决于书写方向。[…]</p>
<h4 id="AlignmentGeometry"><a href="#AlignmentGeometry" class="headerlink" title="AlignmentGeometry"></a>AlignmentGeometry</h4><p>Alignment的 基类，允许文本方向感知分辨率。[…]</p>
<h4 id="AlignmentGeometryTween"><a href="#AlignmentGeometryTween" class="headerlink" title="AlignmentGeometryTween"></a>AlignmentGeometryTween</h4><p>两个AlignmentGeometry之间的插值。[…]</p>
<h4 id="AlignmentTween"><a href="#AlignmentTween" class="headerlink" title="AlignmentTween"></a>AlignmentTween</h4><p>两个对齐之间的插值。[…]</p>
<h4 id="AlignTransition"><a href="#AlignTransition" class="headerlink" title="AlignTransition"></a>AlignTransition</h4><p>Align的 动画版本，可以为其Align.alignment属性设置动画。</p>
<h4 id="AlwaysScrollableScrollPhysics"><a href="#AlwaysScrollableScrollPhysics" class="headerlink" title="AlwaysScrollableScrollPhysics"></a>AlwaysScrollableScrollPhysics</h4><p>滚动物理总是让用户滚动。[…]</p>
<h4 id="AlwaysStoppedAnimation"><a href="#AlwaysStoppedAnimation" class="headerlink" title="AlwaysStoppedAnimation "></a>AlwaysStoppedAnimation <T></h4><p>在给定值停止的动画[…]</p>
<h4 id="Animate-lt-T-gt"><a href="#Animate-lt-T-gt" class="headerlink" title="Animate&lt; T &gt;"></a>Animate&lt; T &gt;</h4><p>一个通过输入动画来生成类型为T的值的对象。[…]</p>
<h4 id="AnimatedAlign"><a href="#AnimatedAlign" class="headerlink" title="AnimatedAlign"></a>AnimatedAlign</h4><p>Align的 动画版本，只要给定的对齐发生变化，就会在给定的持续时间内自动转换child的位置。[…]</p>
<h4 id="AnimatedBuilder"><a href="#AnimatedBuilder" class="headerlink" title="AnimatedBuilder"></a>AnimatedBuilder</h4><p>用于构建动画的通用widget。[…]</p>
<p>AnimatedContainer<br>在一段时间内逐渐更改其值的容器。[…]</p>
<p>AnimatedCrossFade<br>一个widget，它在两个给定的子节点之间交叉淡化，并在它们的大小之间设置动画。[…]</p>
<p>AnimatedDefaultTextStyle</p>
<p>DefaultTextStyle的 动画版本，无论何时给定的样式发生更改，都会在给定的持续时间内自动转换默认文本样式（文本样式以应用于没有显式样式的后代Text widget）。[…]</p>
<p>AnimatedList<br>一个滚动容器，可在插入或移除项目时为其设置动画。[…]</p>
<p>AnimatedListState<br>滚动容器的状态，在插入或移除项目时为其设置动画。[…]</p>
<p>AnimatedModalBarrier<br>一个widget，可以防止用户与自身后面的widget交互，并且可以使用动画颜色值进行配置。[…]</p>
<p>AnimatedOpacity<br>不透明度的 动画版本，只要给定的不透明度发生变化，就会自动转换child在给定持续时间内的不透明度。[…]</p>
<p>AnimatedPadding<br>Padding的 动画版本，无论何时给定的插入更改，它都会在给定的持续时间内自动转换缩进。[…]</p>
<p>AnimatedPhysicalModel<br>PhysicalModel的 动画版本。[…]</p>
<p>AnimatedPositioned<br>定位的 动画版本，可在给定位置发生变化时自动转换child在给定持续时间内的位置。[…]</p>
<p>AnimatedPositionedDirectional<br>PositionedDirectional的 动画版本，可在给定位置发生变化时自动转换child在给定持续时间内的位置。[…]</p>
<p>AnimatedSize<br>动画窗口widget，只要给定子项的大小发生更改，就会在给定的持续时间内自动转换其大小。</p>
<p>AnimatedSwitcher<br>默认情况下，窗口widget在新窗口widget和先前在AnimatedSwitcher上设置为窗口widget的窗口widget之间执行FadeTransition。[…]</p>
<p>AnimatedWidget<br>在给定的Listenable更改值时重建的窗口widget。[…]</p>
<p>AnimatedWidgetBaseState &lt; T扩展了ImplicitlyAnimatedWidget &gt;<br>具有隐式动画的widget的基类。[…]</p>
<p>Animate&lt; T &gt;<br>值为type的动画T。[…]</p>
<p>AnimationController<br>动画控制器。[…]</p>
<p>AnimationEagerListenerMixin<br>一个mixin用dispose契约替换didRegisterListener / didUnregisterListener契约。</p>
<p>AnimationLazyListenerMixin<br>mixin仅在此对象已注册侦听器时帮助侦听另一个对象。</p>
<p>AnimationLocalListenersMixin<br>一个mixin，它实现addListener / removeListener协议，并在调用notifyListeners时通知所有已注册的侦听器。</p>
<p>AnimationLocalStatusListenersMixin<br>一个mixin，它实现addStatusListener / removeStatusListener协议，并在调用notifyStatusListeners时通知所有已注册的侦听器。</p>
<p>AnimationMax &lt; T extends num &gt;<br>跟踪最多两个其他动画的动画。[…]</p>
<p>AnimationMean<br>双 s 的动画，跟踪其他两个动画的平均值。[…]</p>
<p>AnimationMin &lt; T extends num &gt;<br>跟踪最少两个其他动画的动画。[…]</p>
<p>AnimationWithParentMixin &lt; T &gt;<br>通过将其行为推迟到给定的父动画来 实现大多数动画界面。[…]</p>
<p>ASPECTRATIO<br>尝试将子项调整为特定宽高比的widget。[…]</p>
<p>AssetBundleImageKey<br>由AssetImage或ExactAssetImage获取的图像的键。[…]</p>
<p>AssetBundleImageProvider<br>ImageProvider的 一个子类，它知道AssetBundle。[…]</p>
<p>AssetImage<br>从AssetBundle获取图像，根据上下文确定要使用的确切图像。[…]</p>
<p>AsyncSnapshot &lt; T &gt;<br>与异步计算的最新交互的不可变表示。[…]</p>
<p>AutomaticKeepAlive<br>允许子树请求在惰性列表中保持活动状态。[…]</p>
<p>AutomaticKeepAliveClientMixin &lt; T扩展StatefulWidget &gt;<br>为AutomaticKeepAlive的客户提供方便的方法。[…]</p>
<p>BackdropFilter<br>一个widget，它将过滤器应用于现有的绘制内容，然后绘制子项。[…]</p>
<p>BallisticScrollActivity<br>基于物理模拟动画滚动视图的活动。[…]</p>
<p>旗帜<br>在另一个widget的角落上方显示对角线消息。[…]</p>
<p>BannerPainter<br>画横幅。<br>底线<br>根据child的基线定位child的widget。[…]</p>
<p>BeveledRectangleBorder<br>带有扁平或“斜角”角的矩形边框。[…]</p>
<p>BlockSemantics<br>一个窗口widget，它删除在同一个语义容器中绘制在其之前的所有窗口widget的语义。[…]</p>
<p>边境<br>盒子的边框，由四个边组成：顶部，右侧，底部，左侧。[…]</p>
<p>BorderDirectional<br>盒子的边框，由四个边组成，其侧面基于读取方向翻转。[…]</p>
<p>BorderRadius<br>矩形每个角的一组不可变半径。[…]</p>
<p>BorderRadiusDirectional<br>矩形的每个角的一组不可变半径，但是角的指定方式取决于书写方向。[…]</p>
<p>BorderRadiusGeometry<br>BorderRadius的 基类，允许文本方向感知解析。[…]</p>
<p>BorderRadiusTween<br>两个BorderRadius之间的插值。[…]</p>
<p>BorderSide<br>盒子边框的一面。[…]</p>
<p>BottomNavigationBarItem<br>材质的BottomNavigationBar 或带有图标和标题的iOS主题CupertinoTabBar中的交互式按钮。[…]</p>
<p>BouncingScrollPhysics<br>滚动物理环境允许滚动偏移超出内容范围，但随后将内容反弹回这些边界的边缘。[…]</p>
<p>BouncingScrollSimulation<br>与iOS匹配的滚动物理实现。[…]</p>
<p>BoxBorder<br>框边框的基类，可以绘制为矩形，圆形或圆角矩形。[…]</p>
<p>BoxConstraints<br>不可变的布局约束RenderBox布局。[…]</p>
<p>BoxConstraintsTween<br>两个BoxConstraints之间的插值。[…]</p>
<p>BoxDecoration<br>关于如何绘制框的不可变描述。[…]</p>
<p>BoxPainter<br>一个有状态的类，可以绘制一个特定的装饰。[…]</p>
<p>BoxScrollView<br>一个滚动型采用单个子布局的模型。[…]</p>
<p>BoxShadow<br>由盒子投下的阴影。[…]</p>
<p>BuildContext<br>窗口widget树中窗口widget位置的句柄。[…]</p>
<p>生成器<br>一个柏拉图窗口widget，它调用闭包来获取其子窗口widget。[…]</p>
<p>BuildOwner<br>窗口widget框架的管理器类。[…]</p>
<p>帆布<br>用于记录图形操作的界面。[…]</p>
<p>中央<br>一个小孩，它将child置于其中心。[…]</p>
<p>ChangeNotifier<br>可以扩展或混合的类，使用VoidCallback为通知提供更改通知API 。[…]</p>
<p>CheckedModeBanner<br>在已检查模式下运行时 显示标有“DEBUG” 的横幅。 MaterialApp默认构建其中一个。在发布模式下无效。</p>
<p>CircleBorder<br>适合可用空间内圆圈的边框。[…]</p>
<p>ClampingScrollPhysics<br>滚动物理场以防止滚动偏移超出内容边界的环境。[…]</p>
<p>ClampingScrollSimulation<br>与Android匹配的滚动物理实现。[…]</p>
<p>ClipOval<br>使用椭圆剪辑其子项的widget。[…]</p>
<p>ClipPath<br>使用路径剪辑其子项的窗口widget。[…]</p>
<p>ClipRect<br>使用矩形剪辑其子项的widget。[…]</p>
<p>ClipRRect<br>使用圆角矩形剪辑其子项的窗口widget。[…]</p>
<p>颜色<br>ARGB格式的不可变32位颜色值。[…]</p>
<p>ColorFilter<br>描述在绘制形状或使用特定Paint合成图层时应用的滤镜。滤色器是一种采用两种颜色并输出一种颜色的功能。在合成期间应用时，在整个图层与目标合并之前，它将独立应用于正在绘制的图层的每个像素。[…]</p>
<p>ColorSwatch &lt; T &gt;<br>一种颜色，有一个相关颜色的小表称为“样本”。[…]</p>
<p>ColorTween<br>两种颜色之间的插值。[…]</p>
<p>柱<br>在垂直方向排列布局子控件的控件[…]</p>
<p>ComponentElement<br>一个元素是组成其他要素秒。[…]</p>
<p>CompositedTransformFollower<br>一个遵循CompositedTransformTarget的widget。[…]</p>
<p>CompositedTransformTarget<br>CompositedTransformFollower 可以定位的widget。[…]</p>
<p>CompoundAnimation &lt; T &gt;<br>用于组合多个动画的界面。子类只需要实现valuegetter来控制子动画的组合方式。可以链接组合2个以上的动画。[…]</p>
<p>ConstrainedBox<br>一个widget，对其子级施加其他约束。[…]</p>
<p>容器<br>一个结合了常用的绘图组件，定位组件和尺寸组件的便捷组件。[…]</p>
<p>立方体<br>单位区间的三次多项式映射。[…]</p>
<p>曲线<br>单位间隔到单位间隔的映射。[…]</p>
<p>CurvedAnimation<br>将曲线应用于另一个动画的动画。[…]</p>
<p>曲线<br>常见动画曲线的集合。[…]</p>
<p>CurveTween<br>通过给定曲线转换给定动画的值。[…]</p>
<p>CustomClipper &lt; T &gt;<br>用于提供自定义剪辑的界面。[…]</p>
<p>CustomMultiChildLayout<br>一个widget，它使用委托来调整和定位多个子节点。[…]</p>
<p>CustomPaint的<br>一个widget，提供在绘制阶段绘制的画布。[…]</p>
<p>CustomPainter<br>所用的接口CustomPaint的（在部件库）和 RenderCustomPaint（在绘制库）。[…]</p>
<p>CustomPainterSemantics<br>包含描述由CustomPaint使用的Canvas包含的矩形中绘制的信息的属性。[…]</p>
<p>CustomScrollView<br>一个滚动型创建使用棉条自定义滚动效果。[…]</p>
<p>CustomSingleChildLayout<br>一个widget，将其单个子级的布局推迟到委托。[…]</p>
<p>DecoratedBox<br>在儿童绘画之前或之后 绘制装饰的widget。[…]</p>
<p>DecoratedBoxTransition<br>动画版的DecoratedBox是其动画的不同属性装饰。[…]</p>
<p>装饰<br>盒子装饰（应用于Rect的装饰）的描述。[…]</p>
<p>DecorationImage<br>箱子装饰的图象。[…]</p>
<p>DecorationImagePainter<br>装饰图像 的画家。[…]</p>
<p>DecorationTween<br>两个装饰之间的插值。[…]</p>
<p>DefaultAssetBundle<br>一个widget，用于确定其后代的默认资产包。[…]</p>
<p>DefaultTextStyle<br>要应用于后代Text widget而没有显式样式的文本样式。</p>
<p>DefaultWidgetsLocalizations<br>widget库的美国英语本地化版本。[…]</p>
<p>方向性<br>用于确定文本和文本方向敏感渲染对象的环境方向性的窗口widget。[…]</p>
<p>可取消<br>可以通过在指示的方向上拖动来解除的widget。[…]</p>
<p>DragDownDetails<br>使用GestureDragDownCallback的回调的详细信息对象。[…]</p>
<p>DragEndDetails<br>使用GestureDragEndCallback的回调的详细信息对象。[…]</p>
<p>可拖动&lt; T &gt;<br>可以拖动到DragTarget的窗口widget。[…]</p>
<p>DragScrollActivity<br>滚动视图在用户在屏幕上拖动手指时执行的活动。[…]</p>
<p>DragStartDetails<br>使用GestureDragStartCallback的回调的详细信息对象。[…]</p>
<p>DragTarget &lt; T &gt;<br>删除Draggable widget 时接收数据的widget。[…]</p>
<p>DragUpdateDetails<br>使用GestureDragUpdateCallback的回调的详细信息对象。[…]</p>
<p>DrivenScrollActivity<br>基于动画参数设置动画滚动视图的活动。[…]</p>
<p>EdgeInsets<br>四个基本方向中每个方向的一组不可变的偏移量。[…]</p>
<p>EdgeInsetsDirectional<br>四个基本方向中的每个方向上的不可变的偏移集，但其水平分量取决于书写方向。[…]</p>
<p>EdgeInsetsGeometry<br>EdgeInsets的 基类，允许文本方向感知分辨率。[…]</p>
<p>EdgeInsetsGeometryTween<br>两个EdgeInsetsGeometry之间的插值。[…]</p>
<p>EdgeInsetsTween<br>两个EdgeInsets之间的插值。[…]</p>
<p>EditableText<br>基本文本输入字段。[…]</p>
<p>EditableTextState<br>声明EditableText的状态。</p>
<p>ElasticInCurve<br>振荡曲线，在超出其范围的同时增大幅度。[…]</p>
<p>ElasticInOutCurve<br>一条振荡曲线，在超出其范围时会增大然后收缩。[…]</p>
<p>ElasticOutCurve<br>一条振荡曲线，在超出其范围时会缩小幅度。[…]</p>
<p>元件<br>树中特定位置 的Widget实例化。[…]</p>
<p>ErrorWidget<br>呈现异常消息的widget。[…]</p>
<p>ExactAssetImage<br>从AssetBundle获取图像，将其与给定比例相关联。[…]</p>
<p>ExcludeSemantics<br>删除其后代的所有语义的widget。[…]</p>
<p>扩展<br>一个使Row，Column或Flex的子控件扩展尺寸的控件。[…]</p>
<p>FadeInImage<br>在加载目标图像时显示占位符图像的图像，然后在加载时淡入新图像。[…]</p>
<p>FadeTransition<br>动画widget的不透明度。[…]</p>
<p>FileImage<br>将给定的File对象解码为图像，将其与给定的比例相关联。[…]</p>
<p>FittedBox<br>秤，并根据自身内部定位其子契合。[…]</p>
<p>FittedSizes<br>applyBoxFit 返回的这对大小。</p>
<p>FixedColumnWidth<br>将列的大小调整为特定数量的像素。[…]</p>
<p>FixedExtentMetrics<br>ScrollPosition到具有固定项目大小的滚动视图的 度量标准。[…]</p>
<p>FixedExtentScrollController<br>用于滚动视图的控制器，其项目具有相同的大小。[…]</p>
<p>FixedExtentScrollPhysics<br>一种捕捉物理，它总是直接落在物品上而不是滚动范围内的任何地方。[…]</p>
<p>FixedScrollMetrics<br>与Scrollable视口关联的值的不可变快照。[…]</p>
<p>柔性<br>在一维数组中显示其子项的窗口widget。[…]</p>
<p>FlexColumnWidth<br>在布置了所有其他列之后，通过占用剩余空间的一部分来确定列的大小。[…]</p>
<p>灵活<br>控制行，列或Flex的子项如何弯曲的widget。[…]</p>
<p>FlippedCurve<br>曲线是其给定曲线的反转。[…]</p>
<p>流<br>根据FlowDelegate中的逻辑，可以有效地调整和定位子项的widget。[…]</p>
<p>FlowDelegate<br>一个控制流布局外观的委托。[…]</p>
<p>FlowPaintingContext<br>FlowDelegate绘制的 上下文。[…]</p>
<p>FlutterErrorDetails<br>提供给FlutterExceptionHandler回调的信息的类。[…]</p>
<p>FlutterLogoDecoration<br>关于如何绘制Flutter徽标的不可变描述。<br>的FocusManager<br>管理焦点树。[…]</p>
<p>FocusNode<br>焦点树中可以接收焦点的叶节点。[…]</p>
<p>FocusScope<br>建立一个widget可以获得焦点的范围。[…]</p>
<p>FocusScopeNode<br>焦点树中的内部节点。[…]</p>
<p>fontWeight设置<br>用于绘制文本的字形的粗细<br>形成<br>用于将多个表单字段widget（例如TextField widget）分组在一起的可选容器。[…]</p>
<p>FormField &lt; T &gt;<br>单个表单字段。[…]</p>
<p>FormFieldState &lt; T &gt;<br>FormField 的当前状态。传递给FormFieldBuilder方法，用于构造表单字段的widget。</p>
<p>FormState<br>与窗口widget关联的状态。[…]</p>
<p>FractionallySizedBox<br>一个widget，可将其子级调整为总可用空间的一小部分。有关布局算法的更多详细信息，请参阅 RenderFractionallySizedOverflowBox。[…]</p>
<p>FractionalOffset<br>偏移量，表示为大小的一部分。[…]</p>
<p>FractionalOffsetTween<br>两个小数偏移之间的插值。[…]</p>
<p>FractionalTranslation<br>在绘制其子项之前应用转换转换。[…]</p>
<p>FractionColumnWidth<br>将列的大小调整为表的约束’maxWidth的一小部分。[…]</p>
<p>FutureBuilder &lt; T &gt;<br>基于与Future交互的最新快照构建自己的widget。[…]</p>
<p>GestureDetector<br>检测手势的widget。[…]</p>
<p>GestureRecognizerFactory &lt; T扩展了GestureRecognizer &gt;<br>用于创建手势识别器的工厂。[…]</p>
<p>GestureRecognizerFactoryWithHandlers &lt; T扩展了GestureRecognizer &gt;<br>工厂用于创建委托给回调的手势识别器。[…]</p>
<p>GlobalKey &lt; Ť延伸国&lt; StatefulWidget &gt; &gt;<br>整个应用程序中唯一的密钥。[…]</p>
<p>GlobalObjectKey &lt; Ť延伸国&lt; StatefulWidget &gt; &gt;<br>一个全局键，从用作其值的对象获取其标识。[…]</p>
<p>GlowingOverscrollIndicator<br>滚动视图已过度滚动的可视指示。[…]</p>
<p>梯度<br>2D渐变。[…]</p>
<p>GridPaper<br>一个widget，用于绘制一个像素宽的直线网格。[…]</p>
<p>网格视图<br>可滚动的2Dwidget数组。[…]</p>
<p>英雄<br>一个widget，标记其子级为英雄动画的候选者。[…]</p>
<p>HeroController<br>一个导航观察者管理英雄的转变。[…]</p>
<p>HoldScrollActivity<br>滚动活动，除了可以释放以恢复正常的空闲行为之外什么也不做。[…]</p>
<p>HSVColor<br>使用alpha，hue，饱和度和值表示的颜色。[…]</p>
<p>图标<br>图形图标插件与来自于所述的字体的字形绘制IconData如材料的预定IconData以s 图标。[…]</p>
<p>IconData<br>字体标志符号表示的图标说明。[…]</p>
<p>IconTheme<br>控制窗口widget子树中图标的默认颜色，不透明度和大小。[…]</p>
<p>IconThemeData<br>定义图标的颜色，不透明度和大小。[…]</p>
<p>IdleScrollActivity<br>滚动活动，什么都不做。[…]</p>
<p>IgnorePointer<br>在命中测试期间不可见的widget。[…]</p>
<p>图片<br>显示图像的widget。[…]</p>
<p>ImageCache<br>类为imageCache对象。[…]</p>
<p>ImageConfiguration<br>传递给ImageProvider.resolve方法的配置信息，用于选择特定图像。[…]</p>
<p>的ImageIcon<br>来自ImageProvider的图标，例如AssetImage。[…]</p>
<p>的imageinfo<br>一个dart：ui.Image对象及其对应的比例。[…]</p>
<p>ImageProvider &lt; T &gt;<br>识别图像而不提交精确的最终资产。这允许识别一组图像，并且稍后基于环境（例如，设备像素比）来解析精确图像。[…]</p>
<p>ImageShader<br>用于平铺图像的着色器（由Paint.shader使用）。</p>
<p>的ImageStream<br>图像资源的句柄。[…]</p>
<p>ImageStreamCompleter<br>用于管理dart加载的基类：用于ImageStream的ui.Image对象 。[…]</p>
<p>ImplicitlyAnimatedWidget<br>用于构建窗口widget的抽象窗口widget，可在一段时间内逐渐更改其值。[…]</p>
<p>IndexedStack<br>一个堆栈，显示来自子项列表的单个子项。[…]</p>
<p>InheritedElement<br>使用InheritedWidget作为其配置 的Element。</p>
<p>InheritedWidget<br>widget的基类，可以有效地在树中传播信息。[…]</p>
<p>InspectorSelection<br>检查员的可变选择状态。<br>间隔<br>曲线直到开始为0.0 ，然后弯曲（根据曲线从0.0到1.0 结束，然后是1.0。[…]</p>
<p>IntrinsicColumnWidth<br>根据该列中所有单元格的固有尺寸确定列的大小。[…]</p>
<p>IntrinsicHeight<br>一个widget，可以将其子级调整为子级的内在高度。[…]</p>
<p>IntrinsicWidth<br>一个widget，可以将其子级调整为子级的内部宽度。[…]</p>
<p>IntTween<br>两个整数之间的插值。[…]</p>
<p>活着<br>标记一个child需要保持活着，即使它在一个懒惰的列表中，否则将删除它。[…]</p>
<p>KeepAliveHandle<br>甲收听其可以手动触发。[…]</p>
<p>KeepAliveNotification<br>指示此通知气泡必须保持活动的子树，即使它通常会作为优化被丢弃。[…]</p>
<p>键<br>Key是Widget，Element和SemanticsNode的标识符[…]</p>
<p>KeyedSubtree<br>构建其子项的widget。[…]</p>
<p>LabeledGlobalKey &lt; Ť延伸国&lt; StatefulWidget &gt; &gt;<br>带调试标签的全局密钥。[…]</p>
<p>LayerLink<br>LeaderLayer可以注册 的对象。[…]</p>
<p>LayoutBuilder<br>构建可依赖于父窗口widget大小的窗口widget树。[…]</p>
<p>LayoutChangedNotification<br>指示接收此通知的对象的其中一个后代的布局已经以某种方式更改，因此关于该布局的任何假设都不再有效。[…]</p>
<p>LayoutId<br>用于标识CustomMultiChildLayout中的子项的元数据。[…]</p>
<p>LeafRenderObjectElement<br>使用LeafRenderObjectWidget作为其配置 的Element。</p>
<p>LeafRenderObjectWidget<br>RenderObjectWidgets的超类，用于配置没有子项的RenderObject子类。</p>
<p>LimitedBox<br>只有当它不受约束时才限制其大小的盒子。[…]</p>
<p>的LinearGradient<br>2D线性渐变。[…]</p>
<p>ListBody<br>一个widget，它沿着给定的轴顺序排列它的子节点，强制它们到另一个轴的父节点的维度。[…]</p>
<p>可听<br>维护侦听器列表的对象。</p>
<p>倾听者<br>一个widget，它响应指针事件调用回调。[…]</p>
<p>列表显示<br>可线性排列的widget可滚动列表。[…]</p>
<p>ListWheelScrollView<br>一个盒子，可以滚动轮子上的child。[…]</p>
<p>ListWheelViewport<br>显示轮子上的子集子集的视口。[…]</p>
<p>语言环境<br>用于选择用户语言和格式首选项的标识符，由语言和国家/地区组成。这是BCP 47定义的区域设置标识符的子集。[…]</p>
<p>LocalHistoryEntry</p>
<p>LocalHistoryRoute 历史记录中的条目。</p>
<p>LocalHistoryRoute &lt; T &gt;<br>可以通过弹出列表在内部处理返回导航的路由。[…]</p>
<p>本地化<br>为其 定义区域设置child以及子项所依赖的本地化资源。[…]</p>
<p>LocalizationsDelegate &lt; T &gt;<br>用于一组本地化资源类型的工厂，T由Localizationswidget加载 。[…]</p>
<p>LocalKey<br>不是GlobalKey的关键[…]</p>
<p>LongPressDraggable &lt; T &gt;<br>从长按开始使其child可以拖拽。</p>
<p>MaskFilter<br>一个蒙版过滤器，用于在绘制时应用于形状。掩码过滤器是一种采用彩色像素位图的函数，并返回另一个彩色像素位图。[…]</p>
<p>Matrix4<br>4D矩阵。值以列主要顺序存储。</p>
<p>Matrix4Tween<br>两个Matrix4之间的插值。[…]</p>
<p>MatrixUtils<br>用于处理矩阵的实用程序函数。</p>
<p>MaxColumnWidth<br>确定列的大小，使其大小为两个列宽规范的最大值。[…]</p>
<p>MediaQuery<br>建立媒体查询解析给定数据的子树。[…]</p>
<p>MediaQueryData<br>有关介质的信息（例如，窗口）。[…]</p>
<p>MemoryImage<br>将给定的Uint8List缓冲区解码为图像，将其与给定的比例相关联。[…]</p>
<p>MergeSemantics<br>一个widget，它合并其后代的语义。[…]</p>
<p>元数据<br>在渲染树中保存不透明的元数据。[…]</p>
<p>MinColumnWidth<br>确定列的大小，使其大小为两个列宽规范中的最小值。[…]</p>
<p>ModalBarrier<br>一个widget，阻止用户与自身后面的widget交互。[…]</p>
<p>ModalRoute &lt; T &gt;<br>阻止与先前路由交互的路由。[…]</p>
<p>MultiChildLayoutDelegate<br>一个控制多个子项布局的委托。[…]</p>
<p>MultiChildRenderObjectElement<br>使用MultiChildRenderObjectWidget作为其配置 的Element。[…]</p>
<p>MultiChildRenderObjectWidget</p>
<p>RenderObjectWidgets的超类，用于配置具有单个子项列表的RenderObject子类。（此超类仅为该子列表提供存储，它实际上不提供更新逻辑。）</p>
<p>MultiFrameImageStreamCompleter<br>管理图像帧的解码和调度。[…]</p>
<p>NavigationToolbar<br>NavigationToolbar是一个布局助手，用于沿水平轴定位3个widget或widget组，这对于应用程序的导航栏是合理的，例如在Material Design和iOS中。[…]</p>
<p>航海家<br>一个widget，用于管理具有堆栈规则的一组子widget。[…]</p>
<p>NavigatorObserver<br>用于观察导航器行为的界面。</p>
<p>NavigatorState<br>Navigator widget 的状态。</p>
<p>NestedScrollView<br>其中的滚动视图可以嵌套其他滚动视图，其滚动位置本质上是链接的。[…]</p>
<p>NestedScrollViewViewport<br>NestedScrollView使用 的Viewport变体。[…]</p>
<p>NetworkImage<br>从网络获取给定的URL，将其与给定的比例相关联。[…]</p>
<p>NeverScrollableScrollPhysics<br>滚动物理，不允许用户滚动。[…]</p>
<p>通知<br>可以冒泡widget树的通知。[…]<br>NotificationListener &lt; T extends Notification &gt;<br>一个widget，用于侦听通知冒泡树。[…]<br>ObjectKey<br>从用作其值的对象获取其标识的键。[…]<br>抵消<br>不可变的2D浮点偏移量。[…]<br>台下<br>一个widget，它将child放在树中，但没有绘制任何东西，没有让child可用于命中测试，也没有占用父母的任何空间。[…]</p>
<p>OneFrameImageStreamCompleter<br>管理dart：ui.Image对象的加载，用于静态ImageStream（只有一帧）。</p>
<p>不透明度<br>使子项部分透明的widget。[…]</p>
<p>OrientationBuilder<br>构建可依赖于父窗口widget方向的窗口widget树（与设备方向不同）。[…]</p>
<p>OverflowBox<br>一个widget，它对子进程施加的约束不同于从其父进程获得的约束，可能允许子进程溢出父进程。[…]</p>
<p>覆盖<br>一个堆栈条目可以独立进行管理。[…]</p>
<p>OverlayEntry<br>在一个地方叠加，可以包含一个widget。[…]</p>
<p>OverlayRoute &lt; T &gt;<br>在导航器的叠加层中显示窗口widget的路径。</p>
<p>OverlayState<br>Overlay 的当前状态。[…]</p>
<p>OverscrollIndicatorNotification<br>GlowingOverscrollIndicator将开始显示过度滚动指示的 通知。[…]</p>
<p>OverscrollNotification<br>通知Scrollable widget未更改其滚动位置，因为更改会导致其滚动位置超出其滚动边界。[…]</p>
<p>填充<br>一个widget，通过给定的填充来保护其子级。[…]</p>
<p>的PageController<br>PageView 的控制器。[…]</p>
<p>PageMetrics<br>PageView的 度量标准。[…]</p>
<p>PageRoute &lt; T &gt;<br>替换整个屏幕的模态路线。</p>
<p>PageRouteBuilder &lt; T &gt;<br>用于根据回调定义一次性页面路由的实用程序类。[…]</p>
<p>PageScrollPhysics<br>滚动由使用物理浏览量。[…]</p>
<p>PageStorage<br>为此窗口widget子树建立页面存储桶的窗口widget。</p>
<p>PageStorageBucket<br>与应用中的页面关联的存储桶。[…]</p>
<p>PageStorageKey &lt; T &gt;<br>一个ValueKey用于定义PageStorage值将被保存。[…]</p>
<p>页面预览<br>可逐页工作的可滚动列表。[…]</p>
<p>涂料<br>在画布上绘制时使用的样式的说明。[…]</p>
<p>PaintingBinding<br>绑定绘画库。[…]</p>
<p>PaintingContext<br>一个画画的地方。[…]</p>
<p>ParentDataElement &lt; T扩展RenderObjectWidget &gt;<br>使用ParentDataWidget作为其配置 的Element。</p>
<p>ParentDataWidget &lt; T扩展RenderObjectWidget &gt;<br>将ParentData信息挂接到RenderObjectWidget的子 节点的widget的基类。[…]</p>
<p>路径<br>平面的复杂一维子集。[…]</p>
<p>PerformanceOverlay<br>显示性能统计信息 […]</p>
<p>PhysicalModel<br>表示将其子项剪辑为形状的物理层的窗口widget。[…]</p>
<p>PhysicalShape<br>一个widget，表示将其子级剪辑为路径的物理层。[…]</p>
<p>占位符<br>一个widget，用于绘制一个框，表示有一天会添加其他widget的位置。[…]</p>
<p>PointerCancelEvent<br>指针的输入不再指向此接收器。</p>
<p>PointerDownEvent<br>指针已与设备联系。</p>
<p>PointerEvent<br>触摸，手写笔或鼠标事件的基类。[…]</p>
<p>PointerMoveEvent<br>当指针与设备接触时，指针相对于设备移动。[…]</p>
<p>PointerUpEvent<br>指针已停止与设备联系。</p>
<p>PopupRoute &lt; T &gt;<br>在当前路线上覆盖窗口widget的模态路径。</p>
<p>定位<br>一个控件，用于控制堆栈子项的位置。[…]</p>
<p>PositionedDirectional<br>一个widget，用于控制堆栈子项的位置，而不需要提交特定的TextDirection。[…]</p>
<p>PositionedTransition<br>定位的 动画版本，它采用特定的 动画在动画的生命周期内将child的位置从起始位置转换到结束位置。[…]</p>
<p>PREFERREDSIZE<br>具有首选大小的widget。[…]</p>
<p>PreferredSizeWidget<br>窗口widget的接口，如果不受约束，则可以返回此窗口widget所希望的大小。[…]</p>
<p>PrimaryScrollController<br>将ScrollController与子树关联。[…]</p>
<p>ProxyAnimation<br>作为另一个动画的代理的动画。[…]</p>
<p>ProxyElement<br>使用ProxyWidget作为其配置 的Element。</p>
<p>ProxyWidget<br>提供了子窗口widget的窗口widget，而不是构建新窗口widget。[…]</p>
<p>的RadialGradient<br>2D径向渐变。[…]</p>
<p>半径<br>圆形或椭圆形的半径。</p>
<p>RawGestureDetector<br>一个widget，用于检测给定手势工厂描述的手势。[…]</p>
<p>RawGestureDetectorState<br>国家对RawGestureDetector。</p>
<p>RawImage<br>一个直接显示dart：ui.Image的widget。[…]</p>
<p>RawKeyboardListener<br>每当用户按下或释放键盘上的键时调用回调的widget。[…]</p>
<p>RawKeyEvent<br>原始密钥事件的基类。[…]</p>
<p>矩形<br>一个不可变的，2D，轴对齐的浮点矩形，其坐标相对于给定的原点。[…]</p>
<p>RectTween<br>两个矩形之间的插值。[…]</p>
<p>RelativePositionedTransition<br>Positioned的 动画版本，它根据相对于具有指定大小的边界框的rect值转换子项的位置。[…]</p>
<p>RelativeRect<br>一个不可变的2D，轴对齐的浮点矩形，其坐标相对于另一个矩形的边缘给出，称为容器。由于矩形的尺寸是相对于容器的尺寸，因此该类没有宽度和高度成员。为了确定矩形的宽度或高度，将其转换为一个矩形使用toRect（） （通过容器本身的矩形），然后检查该对象。[…]</p>
<p>RelativeRectTween<br>两个相对rects之间的插值。[…]</p>
<p>RenderBox<br>2D笛卡尔坐标系中的渲染对象。[…]</p>
<p>RenderNestedScrollViewViewport<br>NestedScrollView使用 的RenderViewport变体。[…]</p>
<p>渲染对象<br>渲染树中的对象。[…]</p>
<p>RenderObjectElement<br>使用RenderObjectWidget作为其配置 的Element。[…]</p>
<p>RenderObjectToWidgetAdapter &lt; T扩展RenderObject &gt;<br>从RenderObject到Element树的桥梁。[…]</p>
<p>RenderObjectToWidgetElement &lt; T扩展RenderObject &gt;<br>由RenderObject托管的RootRenderObjectElement。[…]</p>
<p>RenderObjectWidget<br>RenderObjectWidgets提供用于配置RenderObjectElement s，这涡卷渲染对象 s，这提供了应用程序的实际渲染。</p>
<p>RenderSliv​​erOverlapAbsorber<br>包裹另一个的条子，迫使其布局范围被视为重叠。[…]</p>
<p>RenderSliv​​erOverlapInjector<br>基于存储在SliverOverlapAbsorberHandle中的值具有条子几何形状的条子 。[…]</p>
<p>RepaintBoundary<br>一个widget，为其子级创建单独的显示列表。[…]</p>
<p>ReverseAnimation<br>与另一个动画相反的动画。[…]</p>
<p>ReverseTween &lt; T &gt;<br>一个Tween，反向评估其父级。</p>
<p>富文本<br>一段富文本。[…]</p>
<p>RootRenderObjectElement<br>树根处的元素。[…]</p>
<p>RotatedBox<br>一个widget，可以将其子项旋转整数个四分之一圈。[…]</p>
<p>RotationTransition<br>动画widget的旋转。</p>
<p>RoundedRectangleBorder<br>带圆角的矩形边框。[…]</p>
<p>路线&lt; T &gt;<br>由导航器管理的条目的抽象。[…]<br>RouteAware<br>知道其当前Route的对象的接口。[…]<br>RouteObserver &lt; R extends Route &gt;<br>一个导航观察者通知RouteAware变化s到他们的状态路线。[…]<br>RouteSettings<br>可能在构建路径时有用的数据。<br>行<br>使子控件横向排列显示的控件。[…]<br>RRect<br>一个不可变的圆角矩形，具有所有四个角的自定义半径。<br>RSTransform<br>由平移，旋转和均匀比例组成的变换。[…]<br>SafeArea<br>一个widget，通过足够的填充来保护其子级，以避免操作系统的入侵。[…]<br>锯齿<br>锯齿曲线，在单位间隔内重复给定次数。[…]</p>
<p>ScaleEndDetails<br>有关GestureScaleEndCallback的详细信息。</p>
<p>ScaleStartDetails<br>有关GestureScaleStartCallback的详细信息。</p>
<p>ScaleTransition<br>动画转换widget的比例。</p>
<p>ScaleUpdateDetails<br>有关GestureScaleUpdateCallback的详细信息。</p>
<p>滚动<br>滚动的widget。[…]</p>
<p>ScrollableState<br>Scrollable widget的 State对象。[…]</p>
<p>ScrollActivity<br>用于滚动活动（如拖动和投掷）的基类。[…]</p>
<p>ScrollActivityDelegate<br>ScrollActivity 的后端。[…]</p>
<p>ScrollbarPainter<br>用于绘制滚动条 的CustomPainter。[…]</p>
<p>ScrollBehavior<br>描述可滚动窗口widget的行为方式。[…]</p>
<p>ScrollConfiguration<br>控制可滚动窗口widget在子树中的行为方式。[…]</p>
<p>ScrollContext<br>Scrollable widget实现 的接口，以便使用 ScrollPosition。[…]</p>
<p>ScrollController<br>控制可滚动的widget。[…]</p>
<p>ScrollDragController<br>当用户在屏幕上拖动手指时滚动滚动视图。[…]</p>
<p>ScrollEndNotification<br>Scrollable widget已停止滚动的 通知。[…]</p>
<p>ScrollHoldController<br>用于保持Scrollable静止的接口。[…]</p>
<p>ScrollMetrics<br>Scrollable内容的 描述，用于建模视口的状态。[…]</p>
<p>ScrollNotification<br>与滚动相关 的通知。[…]</p>
<p>ScrollPhysics<br>确定Scrollable widget的物理特性。[…]</p>
<p>的scrollPosition<br>确定滚动视图中可见的内容部分。[…]</p>
<p>ScrollPositionWithSingleContext<br>滚动位置，用于管理单个ScrollContext的滚动活动 。[…]</p>
<p>ScrollSpringSimulation<br>一个SpringSimulation，其中x的值保证在模拟isDone（）时具有完全最终值。</p>
<p>ScrollStartNotification<br>Scrollable widget已开始滚动的 通知。[…]</p>
<p>ScrollUpdateNotification<br>Scrollable widget已更改其滚动位置的 通知。[…]</p>
<p>滚动型<br>滚动的widget。[…]</p>
<p>语义<br>一个widget，用widget含义的描述来注释widget树。[…]</p>
<p>SemanticsDebugger<br>一个可视化child语义的widget。[…]</p>
<p>着色器<br>Gradient和ImageShader 等对象的基类，它们对应于Paint.shader使用的着色器。</p>
<p>ShaderMask<br>一个widget，它将Shader生成的遮罩应用于其子级。[…]</p>
<p>ShapeBorder<br>形状轮廓的基类。[…]</p>
<p>ShapeDecoration<br>关于如何绘制任意形状的不可变描述。[…]</p>
<p>ShrinkWrappingViewport<br>内部较大的widget，收缩包装在主轴上的子项。[…]</p>
<p>模拟<br>所有模拟的基类。[…]</p>
<p>SingleChildLayoutDelegate<br>用于计算具有单个子项的渲染对象的布局的委托。[…]</p>
<p>SingleChildRenderObjectElement<br>使用SingleChildRenderObjectWidget作为其配置 的Element。[…]</p>
<p>SingleChildRenderObjectWidget<br>RenderObjectWidgets的超类，用于配置具有单个子槽的RenderObject子类。（此超类仅为该子级提供存储，它实际上不提供更新逻辑。）</p>
<p>SingleChildScrollView<br>可以滚动单个窗口widget的框。[…]</p>
<p>SingleTickerProviderStateMixin &lt; T扩展StatefulWidget &gt;<br>提供单个Ticker，配置为仅在启用当前树时打勾，如TickerMode所定义。[…]</p>
<p>尺寸<br>保持2D浮点大小。[…]</p>
<p>SizeChangedLayoutNotification<br>指示接收此通知的对象的其中一个后代的大小已更改，因此有关该布局的任何假设都不再有效。[…]</p>
<p>SizeChangedLayoutNotifier<br>一个widget， 当其子级的布局维度发生更改时自动调度SizeChangedLayoutNotification。[…]<br>SizedBox</p>
<p>具有指定大小的框。[…]</p>
<p>SizedOverflowBox<br>一个特定大小的窗口widget，但将其原始约束传递给其子节点，然后可能会溢出。[…]</p>
<p>SizeTransition<br>动画自己的大小和剪辑并对齐child。[…]</p>
<p>SizeTween<br>两种尺寸之间的插值。[…]</p>
<p>SlideTransition<br>动画widget相对于其正常位置的位置。[…]</p>
<p>SliverChildBuilderDelegate<br>使用构建器回调为子项提供子项的委托。[…]</p>
<p>SliverChildDelegate<br>为儿童提供条子的代表。[…]</p>
<p>SliverChildListDelegate<br>使用明确列表为儿童提供儿童的代表。[…]</p>
<p>SliverFillRemaining<br>包含单个框子项的条子，填充视口中的剩余空间。[…]</p>
<p>SliverFillViewport<br>包含多个子框的子条，每个子框填充视口。[…]</p>
<p>SliverFixedExtentList<br>将多个具有相同主轴范围的盒子项放置在线性阵列中的条子。[…]</p>
<p>SliverGrid<br>将多个盒子儿童放置在二维排列中的条子。[…]</p>
<p>SliverGridDelegate<br>控制网格中图块的布局。[…]</p>
<p>SliverGridDelegateWithFixedCrossAxisCount<br>创建横轴中具有固定数量的切片的网格布局。[…]</p>
<p>SliverGridDelegateWithMaxCrossAxisExtent<br>使用每个都具有最大横轴范围的切片创建网格布局。[…]</p>
<p>SliverList<br>沿着主轴将多个盒子放置在线性阵列中的条子。[…]</p>
<p>SliverMultiBoxAdaptorElement<br>一个懒惰地为SliverMultiBoxAdaptorWidget构建子元素的元素。[…]</p>
<p>SliverMultiBoxAdaptorWidget<br>条子的基类，有多个盒子元素。[…]</p>
<p>SliverOverlapAbsorber<br>包裹另一个的条子，迫使其布局范围被视为重叠。[…]</p>
<p>SliverOverlapAbsorberHandle<br>提供给SliverOverlapAbsorber，SliverOverlapInjector和NestedScrollViewViewport的句柄，用于在NestedScrollView中移位重叠。[…]</p>
<p>SliverOverlapInjector<br>基于存储在SliverOverlapAbsorberHandle中的值具有条子几何形状的条子 。[…]</p>
<p>SliverPadding<br>在另一条棉条的每一侧都应用衬垫的条子。[…]</p>
<p>SliverPersistentHeader<br>当条子滚动到视口的前缘时，尺寸​​变化的条子。[…]</p>
<p>SliverPersistentHeaderDelegate<br>委派配置SliverPersistentHeader。</p>
<p>SliverPrototypeExtentList<br>将盒子放置在线性阵列中并将它们限制为沿主轴具有与原型项相同程度的条子。[…]</p>
<p>SliverSafeArea<br>通过足够的填充来插入另一条条子的条子，以避免操作系统的入侵。[…]</p>
<p>SliverToBoxAdapter<br>包含单个框widget的条子。[…]<br>堆<br>一个widget，用于将其子级相对于其框的边缘定位。[…]</p>
<p>StadiumBorder<br>一个边框，适合体育场形状的边框（两端有半圆形的框），适用于它所应用的widget的矩形。[…]</p>
<p>State &lt; T扩展StatefulWidget &gt;<br>StatefulWidget 的逻辑和内部状态。[…]</p>
<p>StatefulBuilder<br>一个柏拉图窗口widget，它们都具有状态并调用闭包来获取其子窗口widget。[…]</p>
<p>StatefulElement<br>使用StatefulWidget作为其配置 的Element。</p>
<p>StatefulWidget<br>具有可变状态的widget。[…]</p>
<p>StatelessElement<br>使用StatelessWidget作为其配置 的Element。</p>
<p>StatelessWidget<br>一个不需要可变状态的widget。[…]</p>
<p>StatusTransitionWidget<br>在给定动画更改状态时重建的窗口widget。</p>
<p>StepTween<br>地板之间的两个整数之间的插值。[…]</p>
<p>StreamBuilder &lt; T &gt;<br>基于与Stream交互的最新快照构建自身的小组件。[…]</p>
<p>StreamBuilderBase &lt; T，S &gt;<br>基于与指定Stream的交互构建自己的widget的基类。[…]</p>
<p>表<br>为其子项使用表布局算法的窗口widget。[…]</p>
<p>表格边框<br>表格widget的 边框规范。[…]</p>
<p>TableCell的<br>一个widget，用于控制表的子节点的对齐方式。[…]</p>
<p>TableColumnWidth<br>用于描述RenderTable中列的宽度的基类。[…]</p>
<p>的TableRow<br>表 中的一组水平单元格。[…]</p>
<p>TapDownDetails<br>有关GestureTapDownCallback的详细信息，例如位置。</p>
<p>TapUpDetails<br>有关GestureTapUpCallback的详细信息，例如位置。</p>
<p>文本<br>一系列具有单一样式的文本。[…]</p>
<p>文本框<br>包含一段文本的矩形。[…]</p>
<p>TextDecoration<br>在文本附近绘制的线性装饰。</p>
<p>TextEditingController<br>用于可编辑文本字段的控制器。[…]</p>
<p>TextEditingValue<br>用于编辑文本行的当前文本，选择和撰写状态。</p>
<p>TextInputType<br>要优化文本输入控件的信息类型。[…]</p>
<p>TextPainter<br>将TextSpan树绘制到Canvas中的对象。[…]</p>
<p>TextPosition<br>文本字符串中的视觉位置。</p>
<p>的TextRange<br>一串文本中的一系列字符。</p>
<p>TextSelection<br>表示选择的一系列文本。</p>
<p>TextSelectionControls<br>用于构建选择UI的界面，由工具栏widget的实现者提供。[…]</p>
<p>TextSelectionDelegate<br>用于操作选择的界面，供工具栏widget的实现者使用。</p>
<p>TextSelectionOverlay<br>管理一对文本选择句柄的对象。[…]</p>
<p>TextSpan<br>不可变的文本范围。[…]</p>
<p>文字样式<br>一种不可变的样式，其中绘制文本。[…]</p>
<p>TextStyleTween<br>两个TextStyle之间的插值。[…]</p>
<p>质地<br>一个矩形，后端纹理映射在该矩形上。[…]</p>
<p>阈<br>曲线为0.0，直到达到阈值，然后跳到1.0。[…]</p>
<p>TickerFuture<br>表示正在进行的Ticker序列的对象。[…]</p>
<p>TickerMode<br>启用或禁用窗口widget子树中的代码（以及动画控制器）。[…]</p>
<p>TickerProvider<br>由可以销售Ticker对象的类实现的接口。[…]</p>
<p>TickerProviderStateMixin &lt; T扩展StatefulWidget &gt;<br>提供Ticker对象，这些对象配置为仅在启用当前树时打勾，如TickerMode所定义。[…]</p>
<p>标题<br>在操作系统中描述此应用程序的widget。</p>
<p>公差<br>指定距离，持续时间和速度差异的最大允许幅度的结构被认为是相等的。</p>
<p>TrackingScrollController<br>一个ScrollController，其initialScrollOffset跟踪其最近更新的ScrollPosition。[…]</p>
<p>TrainHoppingAnimation<br>此动画通过代理一个动画开始，但可以给出第二个动画。当他们的时间交叉时（或者因为第二个是相反的方向，或者因为一个超过另一个），动画会跳到代理第二个动画，第二个动画成为新的“第一”动画。[…]</p>
<p>转变<br>在绘制其子项之前应用转换的窗口widget。[…]</p>
<p>TransformProperty<br>处理表示变换的Matrix4的属性。</p>
<p>TransitionRoute &lt; T &gt;<br>具有入口和出口过渡的路线。</p>
<p>Tween &lt; T扩展动态 &gt;<br>开始值和结束值之间的线性插值。[…]</p>
<p>TypeMatcher &lt; T &gt;<br>此类是“is”运算符的解决方法，它不接受变量值作为其右操作数</p>
<p>UnconstrainedBox<br>一个widget，它对子节点没有约束，允许它以“自然”大小呈现。[…]</p>
<p>唯一键<br>一个只与自己相等的关键。</p>
<p>UniqueWidget &lt; Ť延伸国&lt; StatefulWidget &gt; &gt;<br>有状态窗口widget的基类，它在树中只有一个膨胀的实例。[…]</p>
<p>UserScrollNotification<br>用户已更改滚动方向的通知。[…]</p>
<p>ValueKey &lt; T &gt;<br>使用特定类型的值来标识自身的钥匙。[…]</p>
<p>ValueNotifier &lt; T &gt;<br>甲ChangeNotifier保存单个值。[…]</p>
<p>速度<br>二维速度。</p>
<p>视口<br>内部更大的widget。[…]</p>
<p>ViewportNotificationMixin<br>Mixin for Notification用于跟踪他们已经通过的RenderAbstractViewport的数量。[…]</p>
<p>窗口widget<br>用于描述元素的配置[…]</p>
<p>WidgetInspector<br>一个widget，可以检查子widget的结构。[…]</p>
<p>WidgetInspectorService<br>GUI工具用于与WidgetInspector交互的服务。[…]</p>
<p>WidgetsApp<br>一个便利类，它包含了应用程序通常需要的许多widget。[…]</p>
<p>WidgetsBinding<br>widget层和Flutter引擎之间的粘合剂。</p>
<p>WidgetsBindingObserver<br>使用Widgets图层绑定注册的类的接口。[…]</p>
<p>WidgetsFlutterBinding<br>基于Widgets框架的应用程序的具体绑定。这是将框架绑定到Flutter引擎的粘合剂。</p>
<p>WidgetsLocalizations<br>用于最低级别的Flutter框架的本地化资源值的接口。[…]</p>
<p>WidgetToRenderBoxAdapter<br>用于在窗口widget树中放置特定RenderBox的适配器。[…]</p>
<p>WillPopScope<br>注册回调以否决用户尝试解除封闭的 ModalRoute。[…]</p>
<p>包<br>一个widget，以多个水平或垂直运行方式显示其子项。[…]</p>
<p>常量<br>kAlwaysCompleteAnimation →const 动画&lt; double &gt;<br>一个总是完整的动画。[…]</p>
<p>const _AlwaysCompleteAnimation()<br>kAlwaysDismissedAnimation →const 动画&lt; double &gt;<br>一个总是被解雇的动画。[…]<br>const _AlwaysDismissedAnimation()</p>
<p>属性<br>debugHighlightDeprecatedWidgets ↔ 布尔<br>显示已弃用的widget的横幅。</p>
<p>读/写<br>debugPrint ↔ DebugPrintCallback<br>将消息打印到控制台，您可以使用“flutter”工具的“logs”命令（“flutter logs”）访问该控制台。[…]</p>
<p>读/写<br>debugPrintBuildScope ↔ 布尔<br>记录所有来电BuildOwner.buildScope。[…]</p>
<p>读/写<br>debugPrintGlobalKeyedWidgetLifecycle ↔ 布尔<br>在取消激活具有全局键的窗口widget时记录，并在重新激活（重新记录）时记录。[…]</p>
<p>读/写<br>debugPrintRebuildDirtyWidgets ↔ 布尔<br>记录每帧构建的脏widget。[…]</p>
<p>读/写<br>debugPrintScheduleBuildForStacks ↔ 布尔<br>记录将widget标记为需要重建的调用堆栈。[…]</p>
<p>读/写<br>debugProfileBuildsEnabled ↔ 布尔<br>Timeline为每个构建的Widget 添加事件。[…]<br>读/写<br>imageCache → ImageCache<br>实现Flutter框架图像缓存的单例。[…]</p>
<p>只读<br>函数<br>applyBoxFit（BoxFit fit， Size inputSize， Size outputSize） → FittedSizes<br>应用BoxFit值。[…]</p>
<p>axisDirectionIsReversed（AxisDirection axisDirection） → bool<br>返回沿给定轴方向行进是否以数字递减顺序访问沿该轴的坐标。[…]</p>
<p>axisDirectionToAxis（AxisDirection axisDirection） → 轴<br>返回包含给定AxisDirection的Axis。[…]</p>
<p>createLocalImageConfiguration（BuildContext context，{ Size size }） → ImageConfiguration<br>基于给定的BuildContext（以及可选的大小） 创建ImageConfiguration。[…]</p>
<p>debugAssertAllWidgetVarsUnset（String reason） → bool<br>如果未更改任何窗口widget库调试变量，则返回true。[…]</p>
<p>debugCheckHasDirectionality（BuildContext context） → bool<br>断言给定的上下文具有Directionality祖先。[…]</p>
<p>debugCheckHasMediaQuery（BuildContext context） → bool<br>断言给定上下文具有MediaQuery祖先。[…]</p>
<p>debugCheckHasTable（BuildContext context） → bool<br>断言给定上下文具有表祖先。[…]</p>
<p>debugChildrenHaveDuplicateKeys（Widget parent， Iterable &lt; Widget &gt; children） → bool<br>如果给定子列表包含任何重复的非null键，则置位。[…]</p>
<p>debugDescribeTransform（Matrix4 transform） → List &lt; String &gt;<br>以对TransformProperty有用的格式返回表示给定转换的字符串列表。[…]</p>
<p>debugDumpApp（） →void<br>打印当前正在运行的应用程序的字符串表示。</p>
<p>debugDumpLayerTree（） →void<br>打印整个图层树的文本表示。</p>
<p>debugDumpRenderTree（） →void<br>打印整个渲染树的文本表示。</p>
<p>debugItemsHaveDuplicateKeys（Iterable &lt; Widget &gt; items） → bool<br>如果给定的项列表包含任何重复的非空键，则断言。[…]</p>
<p>debugPrintStack（{ String label， int maxFrames }） →void<br>使用debugPrint和 FlutterError.defaultStackFilter将当前堆栈转储到控制台。[…]</p>
<p>debugWidgetBuilderValue（Widget小 部件， Widget 内置） →void<br>断言built widget不为空。[…]</p>
<p>decodeImageFromList（Uint8List list） → Future &lt; Image &gt;<br>从字节列表创建图像。[…]</p>
<p>defaultScrollNotificationPredicate（ScrollNotification notification） → bool<br>一个ScrollNotificationPredicate，它检查是否 notification.depth == 0，这意味着通知没有通过任何插入的滚动widget。<br>flipAxis（轴 方向） → 轴<br>返回给定轴的反面。[…]</p>
<p>flipAxisDirection（AxisDirection axisDirection） → AxisDirection<br>返回给定AxisDirection的反向。[…]</p>
<p>getAxisDirectionFromAxisReverseAndDirectionality（BuildContext context， Axis axis， bool reverse） → AxisDirection<br>返回当前Directionality中给定Axis中 的AxisDirection（或反之，如果为true）。[…]</p>
<p>reverse<br>hashList（Iterable &lt; Object &gt; arguments） → int<br>将Iterable中任意数量对象 的Object.hashCode值合并为一个值。如果给定null，则此函数将返回相同的值，就像给出一个空列表一样。<br>hashValues（Object arg01， Object arg02，[ Object arg03 = _hashEnd， Object arg04 = _hashEnd， Object arg05 = _hashEnd， Object arg06 = _hashEnd， Object arg07 = _hashEnd， Object arg08 = _hashEnd， Object arg09 = _hashEnd， Object arg10 = _hashEnd， 对象 arg11 = _hashEnd， 对象 arg12 = _hashEnd， 对象 arg13 = _hashEnd， 对象 arg14 = _hashEnd， 对象 arg15 = _hashEnd， 对象 arg16 = _hashEnd， 对象 arg17 = _hashEnd， 对象 arg18 = _hashEnd， 对象 arg19 = _hashEnd， 对象 arg20 =_hashEnd ]） → int<br>将最多20个对象的哈希码组合成一个值。[…]</p>
<p>paintBorder（Canvas canvas， Rect rect，{ BorderSide top：BorderSide.none， BorderSide right：BorderSide.none， BorderSide bottom：BorderSide.none， BorderSide left：BorderSide.none }） →void<br>在画布上绘制给定矩形周围的边框。[…]</p>
<p>paintImage（{ Canvas canvas， Rect rect， Image image， ColorFilter colorFilter， BoxFit fit， Alignment alignment：Alignment.center， Rect centerSlice， ImageRepeat repeat：ImageRepeat.noRepeat， bool flipHorizo​​ntally：false }） →void<br>将图像绘制到画布上的给定矩形中。[…]</p>
<p>paintZigZag（画布 画布， 油漆 颜料， 偏移 开始， 偏移 结束， int zigs， 双倍 宽度） →void<br>在两点之间画一条线，在连接两点的线上对角线前后切割。[…]</p>
<p>positionDependentBox（{ Size size， Size childSize， Offset target， bool preferBelow， double verticalOffset：0.0， double margin：10.0 }） → Offset<br>将子框放在容器框内，位于目标点的上方或下方。[…]</p>
<p>precacheImage（ImageProvider 提供程序， BuildContext 上下文，{ Size size }） → Future &lt; Null &gt;<br>将图像预取到图像缓存中。[…]</p>
<p>runApp（widget 应用程序） →无效<br>给给定的widget充气并将其附加到屏幕上。[…]</p>
<p>textDirectionToAxisDirection（TextDirection textDirection） → AxisDirection<br>返回在给定TextDirection中进行读取的AxisDirection。[…]</p>
<p>枚举<br>AnimationStatus</p>
<p>动画的状态<br>AppLifecycleState<br>申请可以进入的国家。[…]</p>
<p>轴<br>两个方面的两个基本方向。[…]</p>
<p>AxisDirection<br>沿水平轴或垂直轴的方向。</p>
<p>BannerLocation<br>在哪里展示横幅。[…]</p>
<p>混合模式<br>在画布上绘画时使用的算法。[…]</p>
<p>BlurStyle<br>用于MaskFilter对象中模糊的样式。</p>
<p>边框<br>在边框中 为BorderSide绘制的线条样式。</p>
<p>BoxFit<br>如何将盒子刻在另一个盒子里。[…]</p>
<p>BoxShape<br>渲染Border或BoxDecoration时使用的形状。[…]</p>
<p>ConnectionState<br>与异步计算的连接状态。[…]</p>
<p>CrossAxisAlignment<br>如何将儿童沿横轴放置在柔性布局中。[…]</p>
<p>CrossFadeState<br>指定要显示的两个子项中的哪一个。请参阅AnimatedCrossFade。[…]</p>
<p>DecorationPosition<br>在哪里画一个盒子装饰。</p>
<p>DiagnosticLevel<br>用于过滤显示和省略哪些诊断的各种优先级。[…]</p>
<p>DismissDirection<br>可以驳回不予受理 的方向。</p>
<p>DragAnchor<br>凡可拖动应在拖动过程中被锚定。</p>
<p>FadeInImagePhase<br>FadeInImage经历 的阶段。</p>
<p>FilterQuality<br>图像过滤器的质量级别。[…]</p>
<p>FLEXFIT<br>如何将child铭刻在可用空间内。[…]</p>
<p>FlutterLogoStyle<br>绘制Flutter徽标的可能方法。</p>
<p>字体样式<br>是否在字体中倾斜字形</p>
<p>GrowthDirection<br>相对于滚动偏移轴，条子内容的排序方向。[…]</p>
<p>HitTestBehavior<br>在命中测试期间如何表现。</p>
<p>ImageRepeat<br>如何绘制未被图像覆盖的框的任何部分。</p>
<p>MainAxisAlignment<br>如何在柔性布局中沿着主轴放置子项。[…]</p>
<p>MainAxisSize<br>主轴应占用多少空间。[…]</p>
<p>方向<br>无论是纵向还是横向。</p>
<p>溢出<br>是否应该剪掉溢出的child，或者看到他们的溢出。</p>
<p>PaintingStyle<br>在画布上绘制形状和路径的策略。[…]</p>
<p>PathFillType<br>确定决定如何计算Path内部的缠绕规则。[…]</p>
<p>RenderComparison<br>两个对象之间差异的描述，在它将如何影响渲染的上下文中。[…]</p>
<p>RoutePopDisposition<br>指示是否应弹出当前路由。[…]</p>
<p>SelectionChangedCause<br>指示触发所选文本更改的内容（包括对光标位置的更改）。</p>
<p>StackFit<br>如何调整Stack的未定位子项的大小。[…]</p>
<p>StrokeCap<br>用于行结尾的样式。[…]</p>
<p>StrokeJoin<br>用于线连接的样式。[…]</p>
<p>TableCellVerticalAlignment<br>RenderTable对象中 单元格的垂直对齐选项。[…]</p>
<p>上投放<br>用户交互应适应目标的平台。[…]</p>
<p>TextAffinity<br>是否TextPosition是视觉上的上游或其偏移的下游。[…]</p>
<p>textAlign设置<br>是否以及如何水平对齐文本。</p>
<p>TextBaseline<br>用于对齐文本的水平线。</p>
<p>TextDecorationStyle<br>绘制文本装饰的样式</p>
<p>TextDirection<br>文本流动的方向。[…]</p>
<p>TextOverflow<br>如何处理溢出的文本。</p>
<p>TextSelectionHandleType<br>要显示哪种类型的选择句柄。[…]</p>
<p>TILEMODE<br>定义渐变边缘发生的事情。[…]</p>
<p>VertexMode<br>定义在绘制一组三角形时如何解释点列表。[…]</p>
<p>VerticalDirection<br>盒子垂直流动的方向。[…]</p>
<p>WrapAlignment<br>Wrap 如何对齐对象。[…]</p>
<p>WrapCrossAlignment<br>谁包裹应该在横轴的运行中对齐儿童。</p>
<p>类型定义<br>AnimatedCrossFadeBuilder（Widget topChild， Key topChildKey， Widget bottomChild， Key bottomChildKey） → Widget<br>签名AnimatedCrossFade.layoutBuilder回拨。[…]</p>
<p>AnimatedListItemBuilder（BuildContext context， int index， Animation &lt; double &gt; animation） → Widget<br>使用的构建器回调的签名AnimatedList。</p>
<p>AnimatedListRemovedItemBuilder（BuildContext context， Animation &lt; double &gt; animation） → Widget<br>使用的构建器回调的签名AnimatedListState.removeItem。</p>
<p>AnimatedSwitcherLayoutBuilder（List &lt; Widget &gt; children） → Widget<br>用于生成自定义布局的构建器的签名 AnimatedSwitcher。[…]</p>
<p>AnimatedSwitcherTransitionBuilder（Widget child， Animation &lt; double &gt; animation） → Widget<br>用于生成自定义转换的构建器的签名 AnimatedSwitcher。[…]</p>
<p>AnimationStatusListener（AnimationStatus status） →无效<br>使用附加的听众签名Animation.addStatusListener。</p>
<p>AsyncWidgetBuilder &lt; T &gt; （BuildContext context， AsyncSnapshot &lt; T &gt; snapshot） → Widget<br>签名用于基于异步交互构建widget的策略。[…]</p>
<p>CreateRectTween（Rect begin， Rect end） → Tween &lt; Rect &gt;<br>一个函数的签名，它接受两个Rect实例并返回 RectTween它们之间的转换。[…]</p>
<p>DismissDirectionCallback（DismissDirection direction） →void<br>使用的签名Dismissible表示已在给定的情况下被解雇direction。[…]</p>
<p>DraggableCanceledCallback（速度 速度， 偏移 偏移） →无效<br>在Draggable没有被a接受的情况下丢弃a的签名DragTarget。[…]</p>
<p>DragTargetAccept &lt; T &gt; （T 数据） →无效<br>用于使a DragTarget接受给定数据的签名。[…]</p>
<p>DragTargetBuilder &lt; T &gt; （BuildContext context， List &lt; T &gt; candidateData， List rejectedData） → Widget<br>建立儿童的签名DragTarget。[…]</p>
<p>DragTargetLeave &lt; T &gt; （T 数据） →无效<br>Draggable离开 时签名DragTarget。[…]</p>
<p>DragTargetWillAccept &lt; T &gt; （T 数据） → bool<br>用于确定给定数据是否将被a接受的签名DragTarget。[…]</p>
<p>ElementVisitor（元素 元素） →无效<br>签名回拨给BuildContext.visitChildElements。[…]</p>
<p>ErrorWidgetBuilder（FlutterErrorDetails 详细信息） → Widget<br>构建窗口widget时发生错误时调用的构造函数的签名。[…]</p>
<p>FormFieldBuilder &lt; T &gt; （FormFieldState &lt; T &gt; 字段） → Widget<br>用于构建表示表单字段的窗口widget的签名。[…]</p>
<p>FormFieldSetter &lt; T &gt; （T newValue） →无效<br>签名，以便在表单字段更改值时收到通知。[…]</p>
<p>FormFieldValidator &lt; T &gt; （T 值） → 字符串<br>用于验证表单字段的签名。[…]</p>
<p>GenerateAppTitle（BuildContext context） → String<br>签名WidgetsApp.onGenerateTitle。[…]</p>
<p>GestureDragCancelCallback（） →无效<br>当先前触发的指针GestureDragDownCallback未完成时的签名 。[…]</p>
<p>GestureDragDownCallback（DragDownDetails 详细信息） →void<br>当指针接触屏幕并可能开始移动时的签名。[…]</p>
<p>GestureDragEndCallback（DragEndDetails 详细信息） →void<br>当先前与屏幕接触并且移动的指针不再与屏幕接触时的签名。[…]</p>
<p>GestureDragStartCallback（DragStartDetails 详细信息） →void<br>指针接触屏幕并开始移动时的签名。[…]</p>
<p>GestureDragUpdateCallback（DragUpdateDetails 详细信息） →void<br>当与屏幕接触并且移动的指针再次移动时签名。[…]</p>
<p>GestureLongPressCallback（） →无效<br>当指针长时间保持与同一位置的屏幕保持接触时的签名。</p>
<p>GestureRecognizerFactoryConstructor &lt; T扩展GestureRecognizer &gt; （） →T<br>签名用于实现的闭包GestureRecognizerFactory.constructor。</p>
<p>GestureRecognizerFactoryInitializer &lt; T扩展GestureRecognizer &gt; （T 实例） →无效<br>签名用于实现的闭包GestureRecognizerFactory.initializer。</p>
<p>GestureScaleEndCallback（ScaleEndDetails 详细信息） →无效<br>当指针不再与屏幕接触时的签名。</p>
<p>GestureScaleStartCallback（ScaleStartDetails 详细信息） →无效<br>当与屏幕接触的指针建立焦点并且初始比例为1.0时的签名。</p>
<p>GestureScaleUpdateCallback（ScaleUpdateDetails 详细信息） →无效<br>当与屏幕接触的指针指示新的焦点和/或比例时的签名。</p>
<p>GestureTapCallback（） →无效<br>发生敲击时的签名。</p>
<p>GestureTapCancelCallback（） →无效<br>当先前触发a的指针GestureTapDownCallback不会导致点击时的签名 。</p>
<p>GestureTapDownCallback（TapDownDetails 详细信息） →无效<br>当可能导致点击的指针与屏幕接触时的签名。[…]</p>
<p>GestureTapUpCallback（TapUpDetails 详细信息） →无效<br>当触发敲击的指针停止接触屏幕时的签名。[…]</p>
<p>ImageListener（ImageInfo image， bool synchronousCall） →void<br>报告图像可用的回调签名。[…]</p>
<p>IndexedWidgetBuilder（BuildContext context， int index） → Widget<br>用于为给定索引创建窗口widget的函数的签名，例如，在列表中。[…]</p>
<p>InspectorSelectButtonBuilder（BuildContext context， VoidCallback onPressed） → Widget<br>使用的构建器回调的签名 WidgetInspector.selectButtonBuilder。</p>
<p>InspectorSelectionChangedCallback（） →无效<br>用于选择的签名更改回调 WidgetInspectorService.selectionChangedCallback。</p>
<p>LayoutWidgetBuilder（BuildContext context， BoxConstraints constraints） → Widget</p>
<p>LayoutBuilder构建器函数 的签名。</p>
<p>LocaleResolutionCallback（Locale locale， Iterable &lt; Locale &gt; supportedLocales） → Locale<br>签名WidgetsApp.localeResolutionCallback。[…]</p>
<p>NestedScrollViewHeaderSliv​​ersBuilder（BuildContext context， bool innerBoxIsScrolled） → List &lt; Widget &gt;<br>NestedScrollView用于构建其标题的 签名。[…]</p>
<p>NotificationListenerCallback &lt; T扩展通知 &gt; （T 通知） → bool<br>Notification听众 签名。[…]</p>
<p>OrientationWidgetBuilder（BuildContext context， Orientation orientation） → Widget<br>签名用于构建给定的widget的函数Orientation。[…]</p>
<p>PointerCancelEventListener（PointerCancelEvent 事件） →void<br>用于收听PointerCancelEvent活动的签名。[…]</p>
<p>PointerDownEventListener（PointerDownEvent 事件） →void<br>用于收听PointerDownEvent活动的签名。[…]</p>
<p>PointerMoveEventListener（PointerMoveEvent 事件） →void<br>用于收听PointerMoveEvent活动的签名。[…]</p>
<p>PointerUpEventListener（PointerUpEvent 事件） →void<br>用于收听PointerUpEvent活动的签名。[…]</p>
<p>RouteFactory（RouteSettings 设置） → 路由<br>为给定的路线设置创建路线。[…]</p>
<p>RoutePageBuilder（BuildContext context， Animation &lt; double &gt; animation， Animation &lt; double &gt; secondaryAnimation） → Widget<br>用于PageRouteBuilder构建路径主要内容的函数的签名。[…]</p>
<p>RoutePredicate（路线 路线） → 布尔<br>Navigator.popUntil谓词参数的 签名。</p>
<p>RouteTransitionsBuilder（BuildContext context， Animation &lt; double &gt; animation， Animation &lt; double &gt; secondaryAnimation， Widget child） → Widget<br>用于PageRouteBuilder构建路径转换的函数的签名。[…]</p>
<p>ScrollNotificationPredicate（ScrollNotification 通知） → bool<br>谓词ScrollNotification，用于自定义侦听来自其子项的通知的widget。</p>
<p>SelectionChangedCallback（TextSelection selection， SelectionChangedCause cause） →void<br>用户更改选择（包括光标位置）时报告的回调签名。</p>
<p>SemanticsBuilderCallback（Size size） → List &lt; CustomPainterSemantics &gt;<br>返回的函数的签名CustomPainter.semanticsBuilder。[…]</p>
<p>ShaderCallback（Rect bounds） → Shader<br>签名为创建Shader给定的函数Rect。[…]</p>
<p>StatefulWidgetBuilder（BuildContext context， StateSetter setState） → Widget<br>使用的构建器回调的签名StatefulBuilder。[…]</p>
<p>StateSetter（VoidCallback fn） →无效<br>State.setState功能 的签名。</p>
<p>TextSelectionOverlayChanged（TextEditingValue value， Rect caretRect） →void<br>签名报告变更的筛选组件 TextEditingValue为的目的TextSelectionOverlay。该 caretRect参数给出插入符在的坐标空间中的位置RenderBox由给定的TextSelectionOverlay.renderObject。[…]</p>
<p>TransitionBuilder（BuildContext context， Widget child） → Widget<br>给child建立widget的构建器。[…]</p>
<p>TweenConstructor &lt; T &gt; （T targetValue） → Tween &lt; T &gt;<br>签名Tween工厂。[…]</p>
<p>TweenVisitor &lt; T &gt; （Tween &lt; T &gt; 补间， T targetValue， TweenConstructor &lt; T &gt; 构造函数） → Tween &lt; T &gt;<br>传递回调的签名AnimatedWidgetBaseState.forEachTween。</p>
<p>ValueChanged &lt; T &gt; （T 值） →无效<br>报告基础值已更改的回调签名。[…]</p>
<p>ValueGetter &lt; T &gt; （） →T<br>用于按需报告值的回调签名。[…]</p>
<p>ValueSetter &lt; T &gt; （T 值） →无效<br>用于报告已设置值的回调的签名。[…]</p>
<p>ViewportBuilder（BuildContext context， ViewportOffset position） → Widget<br>用于Scrollable构建视口的签名，通过该视口显示可滚动内容。</p>
<p>VoidCallback（） →无效<br>没有参数的回调签名并且不返回任何数据。</p>
<p>WidgetBuilder（BuildContext context） → Widget<br>用于创建窗口widget的函数的签名，例如StatelessWidget.build 或State.build。[…]</p>
<p>WillPopCallback（） → 未来&lt; bool &gt;<br>签名回拨，验证可以调用Navigator.pop。[…]</p>
<p>异常/错误</p>
<p>FlutterError<br>用于报告特定于Flutter的断言失败和合同违规的错误类。</p>
<p>TickerCanceled<br>当股票代码被取消时，TickerFuture.orCancel未来Ticker对象 抛出异常。</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Flutter" >
    <span class="tag-code">Flutter</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/back-end/2018-07-30-java-design-pattern.html">
        <span class="nav-arrow">← </span>
        
          Java 设计模式
        
      </a>
    
    
      <a class="nav-right" href="/back-end/2019-03-19-server-push.html">
        
          服务器推送
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://oneal.tech/Flutter/2019-03-08-flutter-widget-menu.html';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', '/images/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== '/images/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "Flutter Widget 目录",
        owner: "",
        repo: "",
        oauth: {
          client_id: "",
          client_secret: ""
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    Powered by <a href="https://hexo.io" style="font-weight: bold" target="_blank">Hexo</a>
    | Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>
    | Theme by <a href="https://github.com/yanm1ng" style="font-weight: bold">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'false';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>